<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue CLI 3部署生产环境，跨域做API请求]]></title>
    <url>%2F2019%2F01%2F24%2F2019%2F201901-03%2FVueCLI3%E7%94%9F%E6%88%90%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[微信公众号：一一小知问题或建议，请公众号留言; Vue CLI3通用部署指南指令1234npm install -g serve# -s 参数的意思是将其架设在 Single-Page Application 模式下# 这个模式会处理即将提到的路由问题serve -s dist 使用 history.pushState 的路由参考：常用服务器配置指引:https://router.vuejs.org/zh/guide/essentials/history-mode.html axios实例对baseURL进行指定，使用环境变量VUE_APP_BASE_API： 12345678910import axios from 'axios'import &#123; Message, MessageBox &#125; from 'element-ui'import store from '../store'import &#123; getToken &#125; from '@/utils/auth'// 创建axios实例const service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, // api 的 base_url timeout: 5000 // 请求超时时间&#125;) 在客户端侧代码中使用环境变量官方说明如下：只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。你可以在应用的代码中这样访问它们： 1console.log(process.env.VUE_APP_SECRET) 在构建过程中，process.env.VUE_APP_SECRET 将会被相应的值所取代。在 VUE_APP_SECRET=secret的情况下，它会被替换为 &quot;sercet&quot;。 除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 会是 &quot;development&quot;、&quot;production&quot; 或 &quot;test&quot; 中的一个。具体的值取决于应用运行的模式。 BASE_URL - 会和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。 所有解析出来的环境变量都可以在 public/index.html 中以 HTML 插值中介绍的方式使用。 提示 你可以在 vue.config.js 文件中计算环境变量。它们仍然需要以 VUE_APP_ 前缀开头。这可以用于版本信息 process.env.VUE_APP_VERSION = require(&#39;./package.json&#39;).version。 参考如上说明，我们在项目根路径建立文件.env.production,定义VUE_APP_BASE_API： 12NODE_ENV = 'production'VUE_APP_BASE_API = 'https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin' 执行打包： 打包指令在package.json中做了定义： 123456&gt; "scripts": &#123;&gt; "serve": "vue-cli-service serve",&gt; "build": "vue-cli-service build",&gt; "lint": "vue-cli-service lint"&gt; &#125;,&gt; 本地测试一下： 1234567891011121314bianxh:Template_VueElement bianxh$ pwd/Users/bianxh/gitRepo/OSChina/XiaoZhi/Template_VueElementbianxh:Template_VueElement bianxh$ serve -s dist ┌───────────────────────────────────────────────┐ │ │ │ Serving! │ │ │ │ - Local: http://localhost:5000 │ │ - On Your Network: http://127.0.0.1:5000 │ │ │ │ Copied local address to clipboard! │ │ │ └───────────────────────────────────────────────┘ 在启动页面点击登录，可以看到Request URL指向了API地址： 123456789101112131415161718192021222324Request URL: https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin/user/loginRequest Method: POSTStatus Code: 200 OKRemote Address: 120.27.128.131:443Referrer Policy: no-referrer-when-downgradeAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Origin: http://localhost:5000Connection: keep-aliveContent-Length: 42Content-Type: application/json; charset=utf-8Date: Thu, 24 Jan 2019 06:24:43 GMTRate-Limit-Remaining: 0Rate-Limit-Reset: 1548311083Rate-Limit-Total: 2Server: TengineVary: Accept, OriginX-Request-Id: af10d6c3-c43d-42ed-9547-b588ef3a9216Provisional headers are shownAccept: application/json, text/plain, */*Content-Type: application/json;charset=UTF-8Origin: http://localhost:5000Referer: http://localhost:5000/User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#123;username: "admin", password: "admin1"&#125; 可以看到响应了： 1&#123;"code":50000,"data":"登录账号不对"&#125; 将生产页面部署到git pages上，响应也OK：]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Springboot实现跨域]]></title>
    <url>%2F2019%2F01%2F24%2F2019%2F201901-03%2FSpringboot%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[微信公众号：一一小知问题或建议，请公众号留言 为了实现内网穿透，使用的frp。 请求链路：localhost前端—&gt;云端服务器—&gt;经frp穿透内网到localhost服务端。 在开发环境debug，访问云服务器遇到如下跨域问题： 12xhr.js:178 OPTIONS http://114.116.44.87/user/login 403 (Forbidden):8080/#/login?redirect=%2Fdashboard:1 Access to XMLHttpRequest at 'http://114.116.44.87/user/login' from origin 'http://localhost:8080' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. 看来是跨域被服务端阻止了。 服务端Springboot配置如下，参考官网配置方式实现： 12345678910111213141516@Configurationpublic class CorsConfig &#123; @Bean public WebMvcConfigurer corsConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedOrigins("*") .allowedHeaders("*") .allowedMethods("*"); &#125; &#125;; &#125;&#125; SpringSecurity需要设置允许跨域： WebSecurityConfigurerAdapter实现类WebSecurityConfig的configure方法中，需要允许跨域： 12345678910public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http. //...踩坑了好久，终于记起来需要配置这里了 //如果您使用的是Spring Security，请确保在Spring Security级别启用CORS，以允许它利用Spring MVC级别定义的配置。 .and().cors() //... &#125;&#125; 浏览器第一次会自动和服务器做一次通信。 Origin中的值主要有协议、域名、端口这几种。请求如下： 紧接着本地的第二次请求也被服务器通过了： 可以看到，服务器响应了数据： 参考网址： 浏览器跨域方法与基于Fetch的Web请求最佳实践]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前后端分离实战：使用JSON方式来登录SpringSecurity]]></title>
    <url>%2F2019%2F01%2F23%2F2019%2FSpringSecurity%E5%AF%B9JSON%E7%99%BB%E5%BD%95%E6%A0%BC%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[微信公众号：一一小知问题或建议，请公众号留言; SpringSecurity本身对于Login Parameter的登录处理本身自带的请求页面是这样的： 点击login按钮之后，requst如下，可以看到Content-Type的值是application/x-www-form-urlencoded，username、password、submit是作为Parameter参数做了请求。 完整的如下：123456789101112131415161718192021222324252627282930Request URL: http://localhost:8081/user/loginRequest Method: POSTStatus Code: 401 Remote Address: [::1]:8081Referrer Policy: no-referrer-when-downgradeCache-Control: no-cache, no-store, max-age=0, must-revalidateContent-Type: application/json;charset=utf-8Date: Wed, 23 Jan 2019 02:12:40 GMTExpires: 0Pragma: no-cacheTransfer-Encoding: chunkedX-Content-Type-Options: nosniffX-Frame-Options: DENYX-XSS-Protection: 1; mode=blockAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cache-Control: max-age=0Connection: keep-aliveContent-Length: 38Content-Type: application/x-www-form-urlencodedCookie: JSESSIONID=A977E4AD3F578C5B8FA80BF2DC83C4FAHost: localhost:8081Origin: http://localhost:8081Referer: http://localhost:8081/loginUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36username: bianxhpassword: submit: Login 对应的username和password的接收和处理在WebSecurityConfigurerAdapter子实例中完成，如下：1234567891011121314151617181920212223242526272829package com.template.config;//...@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; //... @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().antMatchers(HttpMethod.OPTIONS).permitAll() .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123; @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) &#123; o.setSecurityMetadataSource(metadataSource); o.setAccessDecisionManager(urlAccessDecisionManager); // url拦截 return o; &#125; &#125;) .and()// .formLogin().loginPage("/login_p").loginProcessingUrl("/login") // 定义响应的url .formLogin().loginProcessingUrl("/user/login") .usernameParameter("username").passwordParameter("password") .permitAll() .and() .logout().permitAll() .and().csrf().disable() .exceptionHandling().accessDeniedHandler(deniedHandler); &#125; //...&#125; 在Vue项目配置中模拟这样的请求如下：123456789import request from '@/utils/request'export function login(username, password) &#123; return request(&#123; url: '/user/login', method: 'post', params: &#123; username, password &#125; &#125;)&#125; Request参数如下：1234567891011121314151617181920212223242526Request URL: http://localhost:8080/user/login?username=bryan&amp;password=1984Request Method: POSTStatus Code: 403 ForbiddenRemote Address: 127.0.0.1:8080Referrer Policy: no-referrer-when-downgradecache-control: no-cache, no-store, max-age=0, must-revalidateconnection: closecontent-length: 0date: Wed, 23 Jan 2019 05:01:03 GMTexpires: 0pragma: no-cachex-content-type-options: nosniffx-frame-options: DENYX-Powered-By: Expressx-xss-protection: 1; mode=blockAccept: application/json, text/plain, */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-aliveContent-Length: 0Cookie: JSESSIONID=DE7E824DB59383D63DA926C5DAA1048EHost: localhost:8080Origin: http://localhost:8080Referer: http://localhost:8080/User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36username=bryan&amp;password=1984 换用JSON方式来登录SpringSecurity配置调整 spring security 是基于javax.servlet.Filter的，因此才能在spring mvc（DispatcherServlet基于Servlet）前起作用。 UsernamePasswordAuthenticationFilter:实现Filter接口，负责拦截登录处理的url，帐号和密码会在这里获取，然后封装成Authentication交给AuthenticationManager进行认证工作 Authentication:贯穿整个认证过程，封装了认证的用户名，密码和权限角色等信息，接口有一个boolean isAuthenticated()方法来决定该Authentication认证成功没; AuthenticationManager:认证管理器，但本身并不做认证工作，只是做个管理者的角色。例如默认实现ProviderManager会持有一个AuthenticationProvider数组，把认证工作交给这些AuthenticationProvider，直到有一个AuthenticationProvider完成了认证工作。 AuthenticationProvider:认证提供者，默认实现，也是最常使用的是DaoAuthenticationProvider。我们在配置时一般重写一个UserDetailsService来从数据库获取正确的用户名密码，其实就是配置了DaoAuthenticationProvider的UserDetailsService属性，DaoAuthenticationProvider会做帐号和密码的比对，如果正常就返回给AuthenticationManager一个验证成功的Authentication 看UsernamePasswordAuthenticationFilter源码里的obtainUsername和obtainPassword方法只是简单地调用request.getParameter方法，因此如果用json发送用户名和密码会导致DaoAuthenticationProvider检查密码时为空，抛出BadCredentialsException。 重写UsernamePasswordAnthenticationFilter123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.template.filter;import com.fasterxml.jackson.databind.ObjectMapper;import com.template.bean.AuthenticationBean;import org.springframework.http.MediaType;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; //attempt Authentication when Content-Type is json if(request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE) ||request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE))&#123; //use jackson to deserialize json ObjectMapper mapper = new ObjectMapper(); UsernamePasswordAuthenticationToken authRequest = null; try (InputStream is = request.getInputStream())&#123; AuthenticationBean authenticationBean = mapper.readValue(is,AuthenticationBean.class); authRequest = new UsernamePasswordAuthenticationToken( authenticationBean.getUsername(), authenticationBean.getPassword()); &#125;catch (IOException e) &#123; e.printStackTrace(); authRequest = new UsernamePasswordAuthenticationToken( "", ""); &#125;finally &#123; setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; //transmit it to UsernamePasswordAuthenticationFilter else &#123; return super.attemptAuthentication(request, response); &#125; &#125;&#125; WebSecurityConfigurerAdapter配置把这个CustomAuthenticationFilter加到spring security的众多filter里面. 12345678910111213141516171819202122232425262728@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .cors().and() .antMatcher("/**").authorizeRequests() .antMatchers("/", "/login**").permitAll() .anyRequest().authenticated() //这里必须要写formLogin()，不然原有的UsernamePasswordAuthenticationFilter不会出现，也就无法配置我们重新的UsernamePasswordAuthenticationFilter .and().formLogin().loginPage("/") .and().csrf().disable(); //用重写的Filter替换掉原有的UsernamePasswordAuthenticationFilter http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);&#125;//注册自定义的UsernamePasswordAuthenticationFilter@BeanCustomAuthenticationFilter customAuthenticationFilter() throws Exception &#123; CustomAuthenticationFilter filter = new CustomAuthenticationFilter(); filter.setAuthenticationSuccessHandler(new SuccessHandler()); filter.setAuthenticationFailureHandler(new FailureHandler()); filter.setFilterProcessesUrl("/login/self"); //这句很关键，重用WebSecurityConfigurerAdapter配置的AuthenticationManager，不然要自己组装AuthenticationManager filter.setAuthenticationManager(authenticationManagerBean()); return filter;&#125; 封装AuthenticationBean类，用lombok简化代码1234567891011package com.template.bean;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class AuthenticationBean &#123; private String username; private String password;&#125; Vue的配置request配置12345678910111213import request from '@/utils/request'export function login(username, password) &#123; return request(&#123; url: '/user/login', method: 'post', // 封装JSON data: &#123; username, password &#125; &#125;)&#125; 效果 在浏览器Network中查看Response 由于我们前后端分类，前端使用的是8080端口，后端使用的是8081端口。所以需要配置一下vue.config.js,允许跨域。 12345678910111213module.exports = &#123; devServer: &#123; proxy: &#123; '/': &#123; target: 'http://localhost:8081', changeOrigin: true, pathRewrite: &#123; '^/': '' &#125; &#125; &#125; &#125; &#125; 后话Request.java可以debug htpp request请求，包位置和关键method如下： 123456789101112131415package org.apache.catalina.connector;/** * Wrapper object for the Coyote request. * * @author Remy Maucherat * @author Craig R. McClanahan */public class Request implements org.apache.catalina.servlet4preview.http.HttpServletRequest &#123; /** * Parse request parameters. */ protected void parseParameters() &#123; //... &#125;&#125; 参考网址 Spring Security配置JSON登录 Spring Security and JSON Authentication 在客户端侧代码中使用环境变量 跨域资源共享 CORS 详解 CORS support in Spring Framework [HTTP请求中的form data和request payload的区别] 未验证：Spring Security拦截器引起Java CORS跨域失败的问题]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Mock来模拟响应式API]]></title>
    <url>%2F2019%2F01%2F22%2F2019%2F%E4%BD%BF%E7%94%A8Mock%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[我们使用的是EasyMock来模拟数据，网站：https://easy-mock.com 编辑接口如下： 输入内容： 1234567891011121314151617181920212223242526272829303132333435&#123; code: function(&#123; _req &#125;) &#123; let username = _req.query.username.trim() let password = _req.query.password.trim() let token = _req.query.token.trim() if (username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; token.length &gt; 0) &#123; if (username === 'admin' &amp;&amp; password === 'admin' &amp;&amp; token === 'admin') &#123; return 20000 &#125; &#125; return 50000 &#125;, data: function(&#123; _req, Mock &#125;) &#123; let username = _req.query.username.trim() let password = _req.query.password.trim() let token = _req.query.token.trim() if (username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; token.length &gt; 0) &#123; if (username === 'admin' &amp;&amp; password === 'admin' &amp;&amp; token === 'admin') &#123; return Mock.mock(&#123; "roles": [ "admin" ], "name": "admin", "avatar": "https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif" &#125;) &#125; &#125; return '登录失败' &#125;&#125; 如上的接口模拟数据中，一部分是模拟响应式数据。如上的接口可以对如下的接口请求参数进行判断和响应。 模拟错误的请求（将username、password、token其中任意一个不匹配）： 1https://easy-mock.com/mock/5c45504832a47545ea4c37cf/base/user/info?password=admin&amp;username=admin&amp;token=admintest 响应： 1234&#123; "code": 50000, "data": "登录失败"&#125; 模拟正确的请求（username、password、token的值都是admin）： 1https://easy-mock.com/mock/5c45504832a47545ea4c37cf/base/user/info?password=admin&amp;username=admin&amp;token=admin 响应： 12345678910&#123; "code": 20000, "data": &#123; "roles": [ "admin" ], "name": "admin", "avatar": "https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif" &#125;&#125; Mock语法参考： Mock.js 1.0 Wiki：https://github.com/nuysoft/Mock/wiki 题外JavaScript代码debug在.vscode文件夹中新建launch.json，设置内容如下： 12345678910111213141516171819202122232425262728293031&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Launch", "type": "node", "request": "launch", "program": "$&#123;workspaceRoot&#125;/test.js", "stopOnEntry": false, "args": [], "cwd": "$&#123;workspaceRoot&#125;", "runtimeExecutable": null, "runtimeArgs": [ "--nolazy" ], "env": &#123; "NODE_ENV": "development" &#125;, "externalConsole": false, "preLaunchTask": "", "sourceMaps": false, "outDir": null &#125;, &#123; "name": "Attach", "type": "node", "request": "attach", "port": 5858 &#125; ]&#125; VS Code debug（PHP, Ruby, Go, C#, Python, C++, Powershell and many others）更详细的配置参考网址：https://code.visualstudio.com/docs/editor/debugging test.js内容如下： 1234567891011var msg = ' test 'kongge1(msg)/* 使用String.trim()函数，来判断字符串是否全为空*/function kongge1(test) &#123; let str = test.trim().length; if (str.length == 0) &#123; console.log('字符串全是空格'); &#125; else &#123; console.log('输入的字符串为:' + test); &#125;&#125; 输出log如下：]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》]]></title>
    <url>%2F2018%2F01%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[第1章 算法简介该使用合并排序算法还是快速排序算法，或者该使用数组还是链表。仅仅改用不同的数据结构就可能让结果大不相同。 使用二分查找时，你猜测的是中间的数字，从而每次都将余下的数字排除一半。 不管我心里想的是哪个数字，你在7次之内都能猜到，因为每次猜测都将排除很多数字！ 一般而言，对于包含n个元素的列表，用二分查找最多需要$log_2 n$步，而简单查找最多需要n步。 接下来，我们用$log \ n$来表示$log_2 n$。 仅当列表是有序的时候，二分查找才管用。例如，电话簿中的名字是按字母顺序排列的，因此可以使用二分查找来查找名字。 知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大O表示法的用武之地。 大O 表示法指出了最糟情况下的运行时间。 一些常见的大O 运行时间： $O(log \ n)$，也叫对数时间，这样的算法包括二分查找。 $O(n)$，也叫线性时间，这样的算法包括简单查找。 $O(n * log \ n)$，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 $O(n^2)$，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。 $O(n!)$，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 算法的速度指的并非时间，而是操作数的增速。 总结： 二分查找的速度比简单查找快得多。 $O(log \ n)$比$O(n)$快。需要搜索的元素越多，前者比后者就快得越多。 算法运行时间并不以秒为单位。 算法运行时间是从其增速的角度度量的。 算法运行时间用大O表示法表示。 附：旅行商故事有一位旅行商。他需要前往5个城市。这位旅行商（姑且称之为Opus吧）要前往这5个城市，同时要确保旅程最短。为此，可考虑前往这些城市的各种可能顺序。 对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。因此，在涉及5个城市时，解决这个问题需要执行120次操作。涉及6个城市时，需要执行720次操作（有720种不同的排列方式）。涉及7个城市时，需要执行5040次操作！ 推而广之，涉及n个城市时，需要执行$n!$（n的阶乘）次操作才能计算出结果。因此运行时间为$O(n!)$，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作。如果涉及的城市数超过100，根本就不能在合理的时间内计算出结果——等你计算出结果，太阳都没了。 这种算法很糟糕！Opus应使用别的算法，可他别无选择。这是计算机科学领域待解的问题之一。对于这个问题，目前还没有找到更快的算法，有些很聪明的人认为这个问题根本就没有更巧妙的算法。面对这个问题，我们能做的只是去找出近似答案。 第2章 选择排序本章内容：学习两种最基本的数据结构——数组和链表。学习第一种排序算法。本章将介绍选择排序。 内存的工作原理需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。 链表的优势在插入元素方面。数组的优势在于读取元素方面。 数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持随机访问。 你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。 需要的总时间为$O(n × n)$，即$O(n^2)$。 选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)，这将在下一章介绍。 小结 计算机内存犹如一大堆抽屉。 需要存储多个元素时，可使用数组或链表。 数组的元素都在一起。 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。 数组的读取速度很快。 链表的插入和删除速度很快。 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。 选择排序示例代码(Python 2版本)12345678910111213141516171819202122# Finds the smallest value in an arraydef findSmallest(arr): # Stores the smallest value smallest = arr[0] # Stores the index of the smallest value smallest_index = 0 for i in range(1, len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_index# Sort arraydef selectionSort(arr): newArr = [] for i in range(len(arr)): # Finds the smallest element in the array and adds it to the new array smallest = findSmallest(arr) newArr.append(arr.pop(smallest)) return newArrprint selectionSort([5, 3, 6, 2, 10]) 第3章 递归本章内容： 学习递归。递归是很多算法都使用的一种编程方法，是理解本书后续内容的关键。 学习如何将问题分成基线条件和递归条件。第4章将介绍的分而治之策略使用这种简单的概念来解决棘手的问题。 递归是我最喜欢的主题之一，它将人分成三个截然不同的阵营：恨它的、爱它的以及恨了几年后又爱上它的。本章还包含大量伪代码。伪代码是对手头问题的简要描述，看着像代码，但其实更接近自然语言。 每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。 调用栈（call stack）。调用栈不仅对编程来说很重要，使用递归时也必须理解这个概念。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-开发Fix集锦]]></title>
    <url>%2F2018%2F01%2F10%2F2018%2F2018-%E5%BC%80%E5%8F%91Fix%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[Spring boot打包及部署打包前，放开web/pom.xml中的注释：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 清理之前的编译： 执行run–&gt;Edit Configurations–&gt;Maven–clean，对应的name是clean，Parameters标签页下的Working Directory指定到项目的根路径，Command Line：clean，点击OK。 Run –&gt; Run ‘clean’。 执行完毕后，可以看到web目录下的target文件夹连带下层的文件被删除。 打包 执行run–&gt;Edit Configurations–&gt;Maven–clean，对应的name是install，Parameters标签页下的Working Directory指定到项目的根路径，Command Line：install，点击OK。 Run –&gt; Run ‘install’。 执行完毕后，可以看到生成了\web\target\web-1.0-SNAPSHOT.war.original文件。解压后放到tomcat8容器下的webapps/ROOT下即可。 递归查询子节点使用函数/存储过程解决查询子节点的问题。如下是测试代码，功能还没调试通过。 分组查询12345678910111213141516171819create temporary table tmp_department_student (`department_id` bigint(20),`student_id` bigint(20)) engine=heapdelimiter // CREATE FUNCTION `getChildDepartmentList`(rootId INT) RETURNS char(255) BEGIN DECLARE str char(255) ; DECLARE cid char(255) ; SET str = ''; SET cid =cast(rootId as CHAR); WHILE cid is not null DO SET str= concat(str,',',cid); SELECT group_concat(id) INTO cid FROM treeNodes where FIND_IN_SET(pid,cid)&gt;0; END WHILE; RETURN str; END // select getChildDepartmentList(1); 递归查询查询一个department树下的学员 分组查询到一个department下的所有字department 12345678910111213141516171819202122DELIMITER $$DROP PROCEDURE IF EXISTS `test`.`getDepartmentChildren`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `getDepartmentChildren`(in rootId INT)BEGIN DECLARE done INT DEFAULT 0; DECLARE b INT; DECLARE cur1 CURSOR FOR SELECT id FROM t_department where parent_id=rootId; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; INSERT into tmpLst select * from t_department where id = rootId; SET @@max_sp_recursion_depth = 100; OPEN cur1; FETCH cur1 INTO b; WHILE done=0 DO CALL getDepartmentChildren(b); FETCH cur1 INTO b; END WHILE; CLOSE cur1; END$$DELIMITER ; 递归查询department，然后从department和student关联表查询对应的student 123456789101112131415161718192021222324DELIMITER $$DROP PROCEDURE IF EXISTS `test`.`getStudentListByDepartment`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `getStudentListByDepartment`(in rootId INT)BEGIN CREATE TEMPORARY TABLE IF NOT EXISTS tmpLst ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `description` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `parent_id` bigint(20) DEFAULT NULL, `is_display` bit(1) DEFAULT NULL, `type` int(11) DEFAULT NULL, `admin_id` bigint(20) DEFAULT NULL, PRIMARY KEY (`id`) ); DELETE FROM tmpLst; CALL getDepartmentChildren(rootId); select DISTINCT s.* from tmpLst tmp, t_student s, t_student_department sd where s.id = sd.student_id and sd.department_id = tmp.id; END$$DELIMITER ; Mysql删除重复数据，保留一条2018-1-10 以部门表为例，假如存在name重复的情况。使用如下语句来删除重复数据，保存id最小的： 1234567delete from t_department where `name` in ( select a.name from (select `name` from t_department group by `name` having count(`name`)&gt;1)a) and `id` not in( select b.id from (select min(`id`) as `id` from t_department group by `name` having count(`name`)&gt;1)b )]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用git rebase来消除提交历史分叉]]></title>
    <url>%2F2018%2F01%2F07%2F2018%2F%E4%BD%BF%E7%94%A8git-rebase%E6%9D%A5%E6%B6%88%E9%99%A4%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%E5%88%86%E5%8F%89%2F</url>
    <content type="text"><![CDATA[在很多时候，随着开发团队的扩容，大家提交代码一段时间过后，就产生很多的合并（merge）节点，对于有代码洁癖的人来说，这个总会觉得很不爽。 那么，merge是如何产生的呢？下面我挑一个常见的冲突的场景，示例一下： 用merge来解决冲突我们来在master分支模拟一次merge的情况，针对README.md，首先A用户编写了首行代码，并提交到了git服务器上内容如下： 1# A用户编写首行代码 同时，B用户在本地编写了首行代码，内容如下：1# B用户编写首行代码 B用户只是在本地电脑上进行了git commit，如下： 123$ git commit -am &quot;B用户编写首行代码&quot;[master c8bfe4f] B用户编写首行代码 1 file changed, 1 insertion(+), 1 deletion(-) 接下来，B用户使用git pull命令将git服务器代码下载并合并到本地，可以看到产生了冲突：1234567891011bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From gitee.com:yyxz/test 45bc85e..fc2c29a master -&gt; origin/masterAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result. 接下来，B用户，修改有冲突的README.md文件，解决冲突，如下： 1234567891011121314151617181920212223bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master|MERGING)$ git statusOn branch masterYour branch and &apos;origin/master&apos; have diverged,and have 1 and 1 different commits each, respectively. (use &quot;git pull&quot; to merge the remote branch into yours)You have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master|MERGING)$ git add README.mdbianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master|MERGING)$ git commit -m &quot;合并A和B用户编写的首行代码&quot;[master 5aa451d] 合并A和B用户编写的首行代码 修改后的README.md文件内容如下：1# 合并A和B用户编写的首行代码 现在B将代码提交到git服务器上，可以看到有两个commit（一个是B对首行代码的提交：c8bfe4f，一个是B刚才的merge动作），如下： 12345678910111213141516171819202122232425bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree cleanbianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git pushCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 695 bytes | 0 bytes/s, done.Total 6 (delta 0), reused 0 (delta 0)To gitee.com:yyxz/test.git fc2c29a..5aa451d master -&gt; masterbianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git log --oneline --graph* 5aa451d (HEAD -&gt; master, origin/master, origin/HEAD) 合并A和B用户编写的首行代码|\| * fc2c29a A用户编写首行代码* | c8bfe4f B用户编写首行代码|/* 45bc85e 初始状态 可以看到，提交历史产生了分叉，接下来我们看看如何使用git rebase消除分叉： git rebase消除分叉A再次修改首行代码，并提交至git服务器，README.md内容如下： 1A再次修改首行代码 B再次在本地修改首行代码，并提交至本地，README.md内容如下： 1B再次修改首行代码 commit如下： 1234bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git commit -am &quot;B再次修改首行代码&quot;[master 21a6c2a] B再次修改首行代码 1 file changed, 1 insertion(+), 1 deletion(-) 接下来，使用git pull --rabase，可以看到冲突，并且进入了rebase状态： 1234567891011121314151617181920212223242526bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git pull --rebaseremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From gitee.com:yyxz/test 5aa451d..ccbb4ff master -&gt; origin/masterFirst, rewinding head to replay your work on top of it...Applying: B再次修改首行代码error: Failed to merge in the changes.Using index info to reconstruct a base tree...M README.mdFalling back to patching base and 3-way merge...Auto-merging README.mdCONFLICT (content): Merge conflict in README.mdPatch failed at 0001 B再次修改首行代码The copy of the patch that failed is found in: .git/rebase-apply/patchWhen you have resolved this problem, run &quot;git rebase --continue&quot;.If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master|REBASE 1/1)$ 此时，B在本地打开README.md文件，可以看到冲突内容如下： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADA再次修改首行代码=======B再次修改首行代码&gt;&gt;&gt;&gt;&gt;&gt;&gt; B再次修改首行代码 解决冲突：修改README.md文件，内容如下： 1再次合并A和B修改的首行代码 使用git add README.md标注冲突已解决： 1234567891011121314151617bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master|REBASE 1/1)$ git add README.mdbianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master|REBASE 1/1)$ git rebase --continueApplying: B再次修改首行代码bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git log --oneline --graph* 1e4c421 (HEAD -&gt; master) B再次修改首行代码* ccbb4ff (origin/master, origin/HEAD) A再次修改首行代码* 5aa451d 合并A和B用户编写的首行代码|\| * fc2c29a A用户编写首行代码* | c8bfe4f B用户编写首行代码|/* 45bc85e 初始状态 可以看到B用户第二次修改是在A修改之后，但是B的提交commit编号21a6c2a被新的编号1e4c421所取代，commit的内容不变。 这时我们看到HEAD -&gt; master，origin/master, origin/HEAD不一致。是因为B用户在本地的修改还未提交至git服务器，通过git status也可以看出来，有1 commit未提交至git服务器： 123456bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 提交后，就OK了。如下： 1234567891011121314151617181920bianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git pushCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 355 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To gitee.com:yyxz/test.git ccbb4ff..1e4c421 master -&gt; masterbianxh@DESKTOP-BIANXH MINGW64 /d/Workspaces/gitee/test (master)$ git log --oneline --graph* 1e4c421 (HEAD -&gt; master, origin/master, origin/HEAD) B再次修改首行代码* ccbb4ff A再次修改首行代码* 5aa451d 合并A和B用户编写的首行代码|\| * fc2c29a A用户编写首行代码* | c8bfe4f B用户编写首行代码|/* 45bc85e 初始状态 现在我们登录到服务器看下最新的内容，如下： 可以通过项目网络图直观地看到，如下：]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[精准扶农思考]]></title>
    <url>%2F2018%2F01%2F06%2F2018%2F%E7%B2%BE%E5%87%86%E6%89%B6%E5%86%9C%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[功能导图 精准扶贫手拉手扶贫帮困，一对一精准到户 食品安全打造从村头到社区食品安全 大众创业科学帮扶大众创业，理性引导万众创新 科普培训科普经营农业标准，培训创业实战技能 农村大市场按标准生产，按需求分配 新零售 生产环节农户（棚户、养殖户）生产设施（土地数、养殖设备）及产量（亩产量、出栏量）等基础数据录入到平台上。 销售环节农户（棚户、养殖户）实时输入数据的基础上，平台实时的数据统计，方便大客户进行批量下单，方便大客户进行批量下单，一次流通，压缩销售投入，节省运输及销售成本投入。让利给供需双方。 流通环节根据销售实时核定货运成本，物流费用实时调整和预测。 采购环节按需申报采购计划，如薄膜、化肥等农用物资。方便统筹，降低采购成本。 线上服务线上提供商品的原产地及环保环节等的宣传。 线下体验提供线下体验通道，需求方提出体验需求，平台汇总，在合适的时间段，需求方可直接到满足供应产量需求的地方去现场体验。时间段可以是农作物的播种期、成长期、成熟期、采收期等等。按需定制。 技能培训 技能视频 1、邀请专家讲课2、技能百科，服务农户 技能百科 精准扶贫通过以上对农户等从一户一村、一年一县的精准统计，实时掌握每户户主的生产销售状况。即可做到精准扶贫、手拉手、一对一精准到户。 统筹流程图如下： 金融服务通过以上精准统计，可以直接把陕西人自己的银行（信合）的端口接入，他们可以直接在网上授信，一键放款。 食品安全监管打造从村头到社区食品安全状况监测。客户可对农产品后续情况予以反馈。农户也建立积分信用排名机制。从点滴汇聚，提升农产品的绿色环保环境。 大众创业通过农村大市场，科学帮扶大众创业，理性引导万众创新。农户也可在平台上发布需求，线下对接。有助于农业资源的再平衡， 物联以大棚菜、养殖户应用场景为例，安装传感器等硬件数据采集设备，实时观测环境数据，预判和引导农户做出决策，促进农作物产量提升，提前防控风险。 推广方案 提升曝光量的目的，也可以调配媒体做宣传，如制作推广视频，或者联系电视台做采访。专家->平台: 录制专业技能扶农视频，上传 Note right of 平台: 汇聚不同种类，不同地域，不同标签的技能视频资源 农民->平台: 拍摄非专业经验视频，上传 平台-->专家: 回馈点播量，及帮助到的人的评论 平台-->农民: 收集进一步的需求，在讨论区进行互助 专家->平台: 提供更高质量、更新的技术指导{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);农民->平台: 发出知识诉求 Note right of 平台: 法律、技能、销售、养殖等 运营->平台: 梳理知识图谱，进行知识归类于清洗 平台-->农民: 提供知识检索引擎{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("sequence-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-1", options);农民->平台: 选择作物分类，种植面积，预估产量 农民->平台: 输入成本投入 运营->平台: 进行数据分析，得到不同维度统计数据 Note right of 运营: 地域、作物分类、产量预期等 平台->农民: 提供区域数据展示，下一步种植计划可参考 农民->平台: 输入实际产量 平台-->专家: 自动收集每日各地域的天气数据，以及最终上报的实际产量数据，便于做不同维度的大数据分析，以及安排接下来的产业统筹工作。{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("sequence-2-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-2-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-2", options);农民->平台: 输入成本、产量、基础收入等数据 农民->金融系统: 提出贷款申请 金融系统->平台: 调研对应用户历年数据，进行征信评估，预估授信额度 Note right of 平台: 保存历年所有农民用户的农业投资及收入基础数据 金融系统-->农民: 定制浮动利率，按风险程度进行惠农利率支持。对征信良好的个人可以进行低利率贷款等 农业保险->平台: 获取农民征信，进行农业保险推广{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("sequence-3-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-3-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-3", options);传感设备->平台: 自动上报温度、湿度、光照数据到平台 Note right of 传感设备: 带温度、湿度、光照的检测和控制的装置 Note right of 平台: 结合历史数据估算产量 平台->农民: 温度或者湿度超过警戒值时给予提醒 农民-->传感设备: 用手机操控，调节大鹏温度、湿度、光照等因素，提升产量{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("sequence-4-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-4-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-4", options);st=>start: 生产 op1=>operation: 流通 op2=>operation: 销售 op3=>operation: 线上服务 e=>end: 线下体验 st->op1->op2->op3->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读软件需求最佳实践]]></title>
    <url>%2F2018%2F01%2F06%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F%E8%AF%BB%EF%BC%9A%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[第一部分 原理、模型和误区 第1章 需求实践现状分析软件项目失败的根源CHAOS报告总结的“软件项目十大败因”中，有五项是与软件需求直接相关的。 不完整的需求 用户可以对需求的完整性进行评价。 要想让用户代表能够更好地参与到完整性评价中来，就必须采用“业务导向”的组织结构，而不是让用户将一大堆技术动作翻译到自己的业务场景中去。 需求规格说明书应该采用业务导向的树型层次结构来组织。 缺乏用户参与 对于需求分析员而言，真正的专业主义是基于业务利益（解决问题、创造机会、提高管控力等）的沟通。通过业务利益争取用户参与到需求活动中，始终让技术解决方案在冰山之下以使用户不中途离开，也许是缓解该问题的很重要的策略。 不切实际的用户期望 从业人员主动地帮助用户更好地理解软件的成本。简单地说，做不到是无效的，要说明为什么做不到才能解决问题。 需求变更频繁 如果只是简单地将所有的需求变更都当作一个问题来看待，那么是无法有效地找出问题的根源的，也无法有针对性地改进需求过程，提高设计的弹性。 提供了不再需要的 真正基于业务领域知识来衡量需求的必要性和充分性是解决之道。 一幅漫画 沟通失真软件需求工程而言，克服沟通失真就成了一个要点。克服失真的关键手段有两个： 文档：用来辅助沟通的，而非代替沟通。 Review：审读 诫语：缓解沟通失真最有效的方法是及时复述。 客户的需求放大潜在原因： 客户希望支付的成本尽可能少，获得的效益尽可能多。要解决该问题并不是件容易的事，一方面需要提升软件估算实践的有效性，另一方面则需要产业成熟度的提高。 解决方案的选择权交给了不熟悉技术的客户。一旦客户代表选择的解决方案不是最合适的，就必将引发后续的需求变更。要缓解这一现象的关键就在于，在需求捕获的过程中多问“what、why”。 项目经理的需求控制项目经理经常会从技术的角度来对需求进行控制，这样就可能造成无法形成对需求的有效理解。 分析人员的技术加工需求分析的本质在于业务分析，而非技术分析。 编码人员的断章取义诫语：业务场景（对不同的用户使用场景进行说明）是需求之魂。 透过表象，分析本质第2章 不同软件项目的需求视图第3章 软件需求与需求工程3.2 需求工程解析3.2.3 需求管理工作要点]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018日志]]></title>
    <url>%2F2018%2F01%2F04%2F2018%2F2018%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Java编程思想2018-1-4 再次使用Tower的一些感受最近因为项目管理需要，又将Tower工具使用了起来。以前也用过其他工具（比如：禅道、Teambition、阿里云RDC协同）。相比起来，Tower会让人觉得足够轻量。 项目管理工具可以做的很复杂，化繁为简是门大学问。下面列举一些我觉得做的很好的地方。 单页面应用会人很好的体验，无缝切换让人觉得是非常舒服的。在此点上，Tower做的很极致。在任务、讨论、文档、日程、文件中切换，堆叠的效果，记录了用户的操作路径，同时也暗示了导航的效果。 细节的视效体验可以提醒可以的操作，通过鼠标Hover过后，文本及图表在细微颜色的变化，以提示用户可以操作。小图标的动效基本用CSS3来实现，页面加载速度也不受影响。比如消息提醒铃铛效果，做的很出彩。有兴趣的童鞋可以关注下fontawesome。很多情况下，通过这里做出来的动效是非常不错的，此时，程序员可以叼根烟头，不用顾忌设计美眉的眼神，在代码的海洋里神游了。还有很多其他Hover效果，比如鼠标滑过单项任务后会展示可进行的操作（编辑、标记成正在进行中、删除）。滑动过人员和时间，提示可以直接在页面上编辑。 无处不在的超链接，无论是在动态、日历，还是在汇报、关注，甚至其他一些应用场景中。点击用户，就跳转到用户信息中，点击任务，就跳转到任务页中。神奇的超链接能做的功能远不止此，当你在做一项任务时，复制浏览器的超链接到任何一处进行评论，提交后超链接自动转换为可点击的任务名称，其他童鞋点击后都可以快速切换至本任务。做到这一步就完了吗？没有，有的讨论或者任务评论会很长，在评论旁边的时间上点击复制链接，粘贴到其他地方，所有看到粘贴结果的用户，都能点击后轻松直接跳转到本讨论或者任务的这一条评论处，高级技能get。 此时，导航也默默地记录了你的操作路径，随时可以轻松返回。 细节之处见真功夫。在很多时候，我们在任务评论了一半，就返回做其他操作去了，过一会再回到此任务的评论处，之前写的草稿会自动恢复。 灵活的任务标签。通过#关键字的办法对任务标签化，点击标签可以通过项目、人员、内容范围进行筛选。 任务清单面板可以拖动，给予用户很好的体验，可以是以列表方式呈现的标准项目，方便更好地组织、细分和管理任务，也可以是看板项目，更适合处理流程化的任务。 喜欢使用WebHooks也可以跟Bearychat、钉钉等对接。查看动态很方便。 和上次使用相比，最近Tower也有了很多可喜的优化： 检查项可以指派给成员了。 在项目任务页，可以针对成员和时间进行筛选。新增了查看成员视图。 不用跑到任务清单的末尾去建立新任务了，清单处点击直达。 在任务中可以编辑通知成员。 怕大家不知道规则，编辑任务时，可以通过点击#来添加标签，点击！来提升任务的优先级。 任务动态和评论用时间线串起来，标题和任务描述的编辑历史终于可查了。 在文件除可以上传新版本了，也加了关注的功能。版本更新都可以知道了。 日历上可以创建日程了，项目任务也能展示在日历中。 还有很多，整体可以看出，之后的每处改进都经过了深度思考，在不影响用户使用习惯的情况下，做增量。 上面没有提到的是，移动端的优化也是很多的。基本可以做到不用安装App，在微信上就能完成常用操作了。 可不可以做减法呢？Tower在周报改成汇报之后，对于周任务的汇总就去掉了。 当然还有很多可以改进的地方，我觉得有的： 比如Markdown的支持，现在不是很好。Teambition虽然做到了全局支持，体验也是不好的。 再如在时间维度上，我们通过日历可以展示未完成的任务，那么已完成的能否展示呢？ 任务每个人都可以点击完成，那么对于任务完成度的验收。现在的办法是验收人需要自己点击关注目标任务。那么这个应用场景能否深挖呢？ 任务现在是在这里手动编排。有没有更好的通过文件（Excel、Project、OminiPlan）导入方式。或者自动拆分多行输入为多个任务？ 最后，再说一下对于任务的安排细分，我觉得这个因人而异，对于自我驱动的人来说，点到为止，任务划分粒度可以大一些。对于日撞一钟的人来说，可以将粒度化小一些，每一到两日跟进成果才是关键。但是所有任务编排的前提，最好是使用SMART原则来划分。还有能让机器自动化完成的事情（比如：持续集成），这个就没有扩散计划资源。 对于项目成果的验证，不是KPI，它会使每个人都落入盲人摸象的陷阱，而是OKR，自顶向下以及自下而上的融合出的蓝图，以及每日精进团队中每个成员的努力带来的提升。毕竟，工具只是一种协作方式，而主体，不是可控的机器，是人。 能在浮躁中沉思，在繁杂中落简，需要的除了定力之外，还是恪守之道、敬畏之心。]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计规范调研]]></title>
    <url>%2F2017%2F12%2F19%2F2017%2F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[初衷网页设计，可能大多数的人第一个想到的就是前端代码和后台的程序，但在做这两个之前，还有一个必须先有的，那就是设计图。没有设计图，前端工程师就没有依据去实现。可能很多人都会说我做网页设计图都没按照规范做过，这个也是可以的，那为什么我们还要花费那么多时间学规范呢？主要有这么几点原因。 1、统一识别规范能使页面相同属性单元识别统一，防止混乱，甚至出现严重错误，避免用户在浏览时无法理解。 2、节约资源除活动推广等个性页面外，设计其他页面使用规范标准能极大的减少设计时间，达到节约资源的目的。 3、重复利用相同属性单元、页面新建时可执行标准重复使用，减少无关信息，就是减少对主体信息传达的干扰，利于阅读和信息传递。 4、上手简单对于设计或前端新手来说，查看标准能使工作上手时间更快，减少出错。 因为存在这几点，所以我们去设计的时候按照规范来还是能更快去进行设计的，而且规范都是别人总结出来的，包含了很多用户体验的最佳数值，这个也是可以参考的。 WEB端设计规范常见网页尺寸 一般网站宽为996px；国内网站大部分还是以1000个像素为界限，因超过1000像素适合在大屏幕上浏览，小屏幕会显得拥挤。国内尺寸设置比较保守，这样可以保证大部分用户舒适的浏览网页。 主流浏览器： chrome IE firefox safari opera 知道了浏览器的设计特点才能更好的设计页面，比如浏览器的头部的操作高度和信息的展示都会有所不同，那么页面在每个浏览器上面的展现就会有所不同。 点击操作：主要通过鼠标点击、滑动、滚动、拖拽。 屏幕适配：由于受限于H5页面在移动设备上的屏幕是各种各样的。对设计影响比较大的主要是屏幕分辨率、尺寸、屏幕方向这些因素。而H5页面会有非常多的一个屏幕尺寸，那么在不同的屏幕下的界面适配就成了一个很大的问题。解决的办法就是通过响应式网站的设计方法来提升在不同分辨率下的兼容性。 响应式设计概念：指的是不同设备、屏幕、分辨率、操作方式（鼠标、键盘、触摸），保证信息在不同环境下表现一致，保证可交互可操作。 举例如下： 做响应式设计时需要遵循一个原则。由于页面的宽度发生了变化，进而信息展现也改变了就是响应式设计。直到最后在手机屏幕上的显示图片信息变成了一列。1、临界点：当页面宽度发生变化的尺寸范围就是临界点的概念。所以做响应式设计时我们需要知道每一个尺寸的宽度范围在多少时我们就可以制定出相对应清晰的一个临界点，制定了临界点之后就知道，当屏幕的宽度范围位于哪一个点的时候，我们的页面信息该如何展示。2、删格：将页面分成几栏、几块。以上是以12删格为基础的案例。它的设计原则就是将页面分成12个等分的栏，然后把页面的内容设计在12栏内。比如左边的一些商品展示它用到了一个删格的单位；其中的一个最大面积的商品展示它用到了比较多的删格；最右侧的操作信息用到了四个删格的比例。3、使用Native App的UI控件：在设计H5页面的同时，能够尽量让样式与Native保持一致；文字字号颜色均可与APP设计一致；减少不必要的手势操作；避免与浏览器的交互冲突，如左右滑动。 尺寸大小因为有些时候我们做出来1920px这么大的宽度，但有些人去浏览的时候他们的电脑宽度才只有1440px，那么旁边的那一部分就会显示不出来，所以我们就需要一个内容区域的大小，来保证不论在多大的显示屏都是可以完整的显示全部的内容，这个内容区域的大小一般设置的是1000左右，以前的设置得比较小一些，像960或者980，现在有些再设计的时候设置得大一点的话可以设计到1200px这么大。但保险点还是1000为好。具体的大小可以根据自己的要求去调整。 字体大小 尽量避免出现一些单数的值。 明确指定标题和正文的字体大小。 对于非系统默认字体，需明确指定。 网页栅格指定对应范围的栅格间距参数。示例如下：上图中以980px为例子，将栅格分了两栏和三栏的时候他们之间的间距为10px。如果分成四栏，那又会有所不一样。这是四栏的情况，而且也分成了两类，一类是二级页面，一类是三级页面，宽度分别为40px和30px。 表单表单与表单的间距，表单与文字的间距，都有一些规范在上面，去设计的时候按照规范去做就行了，当然这些也只是规范，可以适当的放大或者缩小。 留白适当的将内容进行留白，让整个界面的各个元素能明显的区分。板块间距均为10px板块与内容间距均为10px内容单元之间间距为10px内容的间距均为10px 按钮按钮的分类也比较多，有分为运用的按钮，例如交易、购买这些按钮，也有后台的按钮，例如：搜索、提交这些，不同的按钮，大小也是不一样的。 图文规范为了让网页看起来更加的整洁，而不像是堆积起来的，所以也要将文字与图片用距离区分开来，让它文字是文字，图片是图片。图片与文字之间的间距一般是10px，标图与价格的间距也为10px，有些地方也会用到一些描边，这时候描边不要做得太大，一般是1px就够了，颜色也不需要复杂，简单点就好，这里推荐的是浅灰色#CCCCCC。 图标网页上也有很多用图标来代替文字，这样能让页面更加丰富，不会只有文字那样那么单调。就像上面的这些图标，去设计的时候也有几个要求。第一个是制作规格上，要有一个统一的视角，统一的倒角，让他们的外形看起来是一个妈生的，还有就是材质的，不要有些是铁质的，有些又做成木质的，太多样会让页面看起来很乱，还有一个是颜色数量不要超过三种，太多颜色会很杂，所以简单点就好。第二个是制作要求，要会意直观，说得明白点就是要让别人一眼就看出它是谁，这也是它用来区别文字的价值，如果看都看不出是什么，那还不如直接用文字。 很多图标如果能用css3样式完成的，参考这个网站Font Awesome。 banner图banne图是可以根据平面的规范和要求来设计，在网页中宽度一般是满屏不会局限在内容区域里面，高度的话看设计师个人没什么硬性规定。 App设计规范这个设计聚合网站对Android和iOS，手机和平板电脑的设计做了详尽的说明，推荐阅读这个文档。 Android设计规范点击此处查看，也有一个中文版的，点击此处查看。iOS设计规范点击此处查看。 后记以上讲的只是规范，不是规定，所以不需要全部按照它的大小去做，一切依照设计师的想法可以进行更改，不要因为这些规范去限制你天马行空的现象。设计以美观为主，大胆的设计，大胆的创新，做出一些属于自己的设计风格。 参考：设计聚合网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[开发Fix集锦]]></title>
    <url>%2F2017%2F10%2F02%2F2017%2F2017-%E5%BC%80%E5%8F%91Fix%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[2017-4-9 ubuntu服务器环境搭建 配置ssh链接，jdk，hadoop，Samba 配置Linux环境属性 修改终端字体大小 1sudo dpky-reconfigure console-setup 第一次root用户解锁操作 修改root密码 1sudo passwd root 用户注销 1logout ubuntu16.04切换到root用户登录 1su root 以root用户进行登录 who命令来查看是谁登录。 关闭Linux防火墙 1ufw disable 卸载iptables组件 1apt-get remove iptables 安装vim 1apt-get install vim Hostname主机 1vim /etc/hosts ssh连接配置 ssh工具： 1apt-get install openssh-server 启动ssh服务： 1/etc/init.d/ssh start 查看是否服务已经启动： 1ps -e | grep sshd 解决默认不能root用户登录使用ssh的问题： 1vim /etc/ssh/sshd_config 随后修改PermitRootLogin，将内容设置为yes ftp服务 安装 1apt-get install vsftpd 修改默认ftp用户的密码 1passwd ftp ftp完成后，会自动创建目录 /srv/ftp，修改权限1chmod 777 /srv/ftp 如果要ftp正常工作，修改配置文件1vim /etc/vsftpd.conf 修改如下参数：123456789anonymous_enable NO //不允许匿名登录...local_enable YES //允许本地用户登录...write_enable=YES //用户具有写权限...chroot_local_user=YES //是否将所有用户限制在主目录...chroot_list_enable=YES //是否启动限制用户的名单 定义名单设置的目录（名单中可以设置多个账号） 1chroot_list_file=/etc/vsftpd.chroot_list 增加一个服务配置 pam-service_name=vsftpd ，注意文件中不能存在此条信息的重复数据（我新增了一条，踩了个坑）。 增加一个新的文件，写上一个用户 1vim /etc/vsftpd.chroot_list 在第一行写上ftp，表示新增一个用户 修改 vim /etc/pam.d/vsftpd,注释掉以下内容： 12# auth required pam_shells.so 启动服务 1service vsftpd start JDK的安装与配置 下载Linux版本jdk. XShell使用rz命令传到服务器 解压 1root@ubuntu:/home/bianxh/Downloads# tar xzvf jdk-8u111-linux-x64.tar.gz -C /usr/local 打开环境文件进行配置： 1vim /etc/profile 123export JAVA_HOME=/usr/local/jdk1.8.0_111export PATH=$PATH:$JAVA_HOME/bin:export CLASS_PATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 让配置立刻生效 1source /etc/profile 测试下是否生效成功 1234root@ubuntu:/usr/local/jdk1.8.0_111# java -versionjava version &quot;1.8.0_111&quot;Java(TM) SE Runtime Environment (build 1.8.0_111-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode) 在Linux中安装Hadoop 上传Hadoop文件并解压缩 1root@ubuntu:/home/bianxh/Downloads# tar xzvf hadoop-2.6.0.tar.gz -C /usr/local 配置环境变量，修改/etc/profile 12export HADOOP_HOME=/usr/local/hadoop-2.6.0export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin: 让配置立刻生效 1source /etc/profile hadoop依赖jdk 1root@ubuntu:/usr/local/hadoop-2.6.0/etc/hadoop# vim hadoop-env.sh 12#export JAVA_HOME=$&#123;JAVA_HOME&#125;export JAVA_HOME=/usr/local/jdk1.8.0_111 Linux常用命令 设置当前系统时间命令示例： 1$ date –set “10/15/2009 20:18” 递归解压bz2g格式压缩包示例： 1tar -jxvf cygwin.tar.bz2 -C 指定目录 Samba服务器文件夹权限分配实例（修改/etc/samba/smb.conf）： 123456789[bianxh] comment = File Share of bianxh browseable = yes path = /home/bianxh/ writable = yes create mask = 777 valid users = public bianxh directory mask = 777 available = yes 2017-04-28 Mac开发环境搭建 Mac下安装brew、Redis、zookeeper过程中踩过的坑。 Mac serria偏好设置找到“打开任意来源”命令 1$ sudo spctl --master-disable 重建MAC的右键打开方式列表Mac上选中一个文件点击右键会有一个“Open With”菜单，如果你装过多个虚拟机等，这个菜单会出现很多windows系统的程序，从而使这个菜单十分混乱，可以使用以下命令行来清除所有的重复项。1/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -kill -r -domain local -domain user;killall Finder;echo “Open With has been rebuilt, Finder will relaunch“ Mac Web开发环境配置安装brew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install\&quot; 安装下载工具 1brew install wget 安装Redis1234$ wget http://download.redis.io/releases/redis-3.0.7.tar.gz$ tar xzf redis-3.0.7.tar.gz$ cd redis-3.0.7$ make 启动redis 1$ src/redis-server redis.conf 连接上以后，关闭redis 12$ src/redis-cli$ 127.0.0.1:6379&gt; SHUTDOWN 测试redis 12345$ src/redis-cliredis&gt; set foo barOKredis&gt; get foo"bar" # Mac OS命令行下使用SublimeText打开文本文件 打开用户配置文件 1vim ~/.bash_profile 添加如下alias 12alias subl=&quot;&apos;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&apos;&quot;alias ll=&apos;ls -al&apos; 如果不添加别名，也可以选择将路径添加到环境变量下。这里的路径根据实际情况可能会有所不同。 wq保存后回到命令行执行以下命令使其生效： 1source ~/.bash_profile 命令行使用，这里我们假设在命令行用SublimeText打开.bash_profile，则执行如下： 1subl ~/.bash_profile 安装zookeeper1$brew install zookeeper 启动服务 1234$ sudo zkServer startZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgStarting zookeeper ... STARTED 在MAC下需要用sudo命令来启动此服务，否则会失败。 查看zookeeper运行及状态 1234567$ zkServer statusZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgMode: standalone$zkCliConnecting to localhost:2181 停止服务 1234$ zkServer stopZooKeeper JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgStopping zookeeper ... STOPPED 安装邮件服务 James server12$ subl ~/.bash_profileexport JAMES_SRC_HOME=/usr/local/james-project/james-project 安装maven，参考教程 1$ brew install maven 默认安装位置是 1$ /usr/local/Cellar/maven/3.3.9 Fix problemsmaven报错：1Could not calculate build plan: Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6 解决方法： 1、查看windows -&gt; Preferences -&gt; maven 的settings.xml文件中.m2的位置 2、然后将.m2/repository/org/apache/maven/plugins目录下的文件夹全部删除 3、选中maven项目，右键 –&gt; maven –&gt; update，让maven重新下载依赖包 注：此IDE自带maven插件，不需要再自己下载安装maven插件 mac下，dubbo注册zookeeper，ip地址是一个虚拟的地址，并不是局域网的本机ip在搭建zookeeper的过程中，使用dubbo获取的地址总是220.250.64.26，通过jdk代码调用来看，确实是这样：123456789101112InetAddress ia=null;try &#123;ia=ia.getLocalHost();String localname=ia.getHostName();String localip=ia.getHostAddress();System.out.println("本机名称是："+ localname);System.out.println("本机的ip是 ："+localip);&#125; catch (Exception e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125; cosole输出：12本机名称是：bogon本机的ip是 ：220.250.64.26 220.250.64.26是虚拟的地址，导致项目在tomcat下无法正常运行。在mac终端可以看到，本机hostname是bogon，于是我们重设hostname，命令如下：12$ sudo scutil --set HostName bianxh$ sudo scutil --set LocalHostName bianxh 然后修改hosts文件，1bogon:redis-3.0.7 bianxh$ subl /etc/hosts 在末位新增两行：12127.0.0.1 bianxh::1 bianxh 重新运行上面的java代码，可以看到ip地址正常了： 12本机名称是：bianxh本机的ip是 ：127.0.0.1 接下来，通过dubbo注册zookeeper，可以看到console输出的注册地址就正常了，变为局域网内的本机地址。 2017-09-16-微信开发：scope参数错误或没有scope权限解决方法1、确保请求参数的顺序（注意response_type和scope前后顺序）： scope为snsapi_basehttps://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect scope为snsapi_userinfohttps://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect 2、确保在合适的公众号上操作，比如我在正式公众服务号上进入一个需要经过OAuth的链接，却在代码中走的测试号的appid，那也会提示这个错误。 3、如果还是不行，那再到微信管理后台确认下，修改“网页帐号–&gt;网页授权获取用户基本信息”，使其生效，如图： 参考文档： 微信公众平台 微信公众平台测试号管理配置页面。 2017-09-16-微信服务号绑定踩过的坑首先绑定域名，方法： 设置–&gt;公众号设置–&gt;功能设置 然后可以设置业务域名、JS接口安全域名、网页授权域名。 将文件MP*.txt（点击下载）[例如wx.qq.com/MP.txt；若填写路径，将文件放置在路径目录下，例如wx.qq.com/mp/.txt），并确保可以访问。](http://0.0.0.1/) 将txt拷贝到Tomcat下域名对应的路径下，配置server.xml，路径：C:\apache-tomcat-7.0.79\webapps\helloworld 2017-09-16-点击div标签下的href不跳转到目标页面，而是跳转到首页的问题a标签如果不做任何定义，点击其中的元素时，会默认跳转到主页。123&lt;a href=&quot;&quot; class=&quot;stars&quot;&gt;...&lt;/a&gt; 上面点击star星，就会跳转到路径”/“下，解决办法如下：123&lt;a href=&quot;javascript:void(0)&quot; class=&quot;stars&quot;&gt;...&lt;/a&gt; 原理是：单击此处什么也不要做，让此区域下方的组件处理href事件。 2017-09-16-简单的整数或者小数判断正则表达式123456789101112131415/** * 正则表达式规则：-号出现0或者1次，0-9出现多次，小数点出现0或者1次，0-9出现多次 * @param str * @return */public static boolean isNumeric(String str) &#123; if (str != null &amp;&amp; !str.isEmpty()) &#123; Pattern pattern = Pattern.compile("-?[0-9]*.?[0-9]*"); Matcher isNum = pattern.matcher(str); if (isNum.matches()) &#123; return true; &#125; &#125; return false;&#125; 2017-09-16-获取页面div下级的innerHtml123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;function getValue()&#123;var x=document.getElementById("myHeader")var y= $("#test #myHeader")[0];alert(x.innerHTML);alert(y.innerHTML);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test"&gt;&lt;h1 id="myHeader" onclick="getValue()"&gt;这是标题&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;点击标题，会提示出它的值。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2017-09-16-获取高德地图定位的js源码Key是我申请的，可以直接用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width"&gt;&lt;title&gt;浏览器定位&lt;/title&gt;&lt;link rel="stylesheet" href="http://cache.amap.com/lbs/static/main1119.css" /&gt;&lt;script type="text/javascript" src="http://webapi.amap.com/maps?v=1.3&amp;key=b6df90d2cfda9508fb2106ae6273d7ea"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://cache.amap.com/lbs/static/addToolbar.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id='container'&gt;&lt;/div&gt; &lt;div id="tip"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var map, geolocation; //加载地图，调用浏览器定位服务 map = new AMap.Map('container', &#123; resizeEnable: true &#125;); map.plugin('AMap.Geolocation', function() &#123; geolocation = new AMap.Geolocation(&#123; enableHighAccuracy: true,//是否使用高精度定位，默认:true timeout: 10000, //超过10秒后停止定位，默认：无穷大 buttonOffset: new AMap.Pixel(10, 20),//定位按钮与设置的停靠位置的偏移量，默认：Pixel(10, 20) zoomToAccuracy: true, //定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false buttonPosition:'RB' &#125;); map.addControl(geolocation); geolocation.getCurrentPosition(); AMap.event.addListener(geolocation, 'complete', onComplete);//返回定位信息 AMap.event.addListener(geolocation, 'error', onError); //返回定位出错信息 &#125;); //解析定位结果 function onComplete(data) &#123; var str=['定位成功']; str.push('经度：' + data.position.getLng()); str.push('纬度：' + data.position.getLat()); if(data.accuracy)&#123; str.push('精度：' + data.accuracy + ' 米'); &#125;//如为IP精确定位结果则没有精度信息 str.push('是否经过偏移：' + (data.isConverted ? '是' : '否')); var point = data.position.getLng()+","+data.position.getLat(); poiToaddress(point); document.getElementById('tip').innerHTML = str.join('&lt;br&gt;'); &#125; //解析定位错误信息 function onError(data) &#123; document.getElementById('tip').innerHTML = '定位失败'; &#125; //坐标点转地址 function poiToaddress(poi) &#123; AMap.plugin(["AMap.Geocoder"], function () &#123; var geocoder = new AMap.Geocoder(&#123; city: "0315", //城市，默认：“全国” radius: 500 //范围，默认：500,以已知坐标为中心点，radius为半径，返回范围内兴趣点和道路信息 &#125;); geocoder.getAddress(poi, function (status, result) &#123; if (status === 'complete' &amp;&amp; result.info === 'OK') &#123; var address = result.regeocode.formattedAddress; //返回地址描述 address2point(address); console.log("地址：："+address); alert("当前地址:" + address); &#125; &#125;); &#125;) &#125; //地址转坐标 function address2point(address) &#123; AMap.plugin(["AMap.Geocoder"], function () &#123; var geocoder = new AMap.Geocoder(&#123; city: "0315", //城市，默认：“全国” radius: 500 //范围，默认：500,以已知坐标为中心点，radius为半径，返回范围内兴趣点和道路信息 &#125;); geocoder.getLocation(address, function (status, result) &#123; if (status === 'complete' &amp;&amp; result.info === 'OK') &#123; var geocode = result.geocodes[0]; var resultStr = geocode.location.lng + "," + geocode.location.lat; console.log(resultStr); alert("resultStr" + resultStr); &#125; &#125;); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2017-09-16-解析微信xml消息使用的jar包使用XStream，下载地址：XStream - Download 从里面找上门的3个jar包并加载。 2017-09-16-css图片资源加载失败？之前的css代码是这样写（资源使用的是绝对路径）： background: url(resources/img/star2.png) no-repeat !important; 结果报资源找不见：1zepto.min.js:1 GET http://localhost:8080/helloworld/resources/static/css/resources/img/star2.png 404 (Not Found) 图片加载失败，找了一下，这个位置其实是有这个文件的： 改成相对路径就好了： background: url(../img/star2.png) no-repeat !important; 2017-09-16-Eclipse-Java-EE找不到JSTL在Eclipse下提示：1Can not find the tag library descriptor for “http://java.sun.com/jsp/jstl/core” 访问对应的页面时，console控制台提示：1The absolute uri: [http://java.sun.com/jsp/jstl/core] cannot be resolved in either web.xml or the jar files deployed with this application 从Tomcat官网去下载JSTL jar包，链接是：Apache Taglibs Downloads 注意这4个都下载： 拷贝下载后的文件到tomcat lib下，如图： 右键点击Eclipse下对应的Project，Build path –&gt; Config Build Path，进入Liabraries标签页，添加Liabrary，如下： 2017-09-16-Eclipse-Java-EE-IDE修改web项目部署路径如果添加了项目到tomcat下那么按照下面的步骤进行配置 1、找到Server面板，右击当前的那个Tomcat，先remove掉其中所有的工程。 2、再右击那个Tomcat，选择Clean，清空一下。 注意：只有clean之后，才能编辑Server Locations。 3、双击那个Tomcat，会打开属性面板，找到左边第二个Server Locations。 选择第二个会在Tomcat路径下创建一个名为wtpwebapps文件夹，存放Tomcat发布的web项目； 选择第三个，你可以在Server Path中输入你想要的路径，保存即可。 然后右击Server，Add and Remove…就可以添加项目来试试看了。 2017-09-16-EL表达式，结果取整1&lt;fmt:formatNumber type=&quot;number&quot; value=&quot;$&#123;8/7&#125;&quot; maxFractionDigits=&quot;0&quot;/&gt; 其中maxFractionDigits=”0”表示保留0位小数，这样就可以实现取整了。同时这里是按照四舍五入的规则来进行取整的。如果是${2/6}结果就是0，如果是${6/7}结果就是1。在这里我们同样也可以设置保留n为小数，仅需要设置maxFractionDigits=”n”即可实现。 2017-09-16-Form表单提交后不跳转到新页面去掉form表单的这个属性：1target='hiddenwin' 2017-09-16-hibernate-hql实战小结表关联查询汇总排名 查询报名记录1select o.id as id, o.name as org_name from t_sign_up t, t_student s, t_org o where t.student_id = s.id and s.org_id=o.id 结果如下，可以看到1个单位下有4条报名记录，另外一个单位下有2条： 汇总报名记录，并按照统计次数降序：1select o.id as id, o.name as org_name, count(t.id) as org_count from t_sign_up t, t_student s, t_org o where t.student_id = s.id and s.org_id=o.id group by o.name order by org_count desc 效果如下： 如上sql，在Mysql测试成功，移植到hql时，需要给经过重名的orgCount加上引号，否则会报出现报错，报找不到orgCount字段，如下：1select o.id as id, o.name as orgName, count(t.id) as orgCount from SignUp t, Student s, Org o where t.studentId = s.id and s.orgId=o.id group by o.name order by 'orgCount' desc 数据比较多的时候，需要进行分页展示，相关的，我们要构建countQuery来查询结果总数目，在如上的sql上进行统计，如下：1String countQuery = "select count(*) from (select o.id as id, o.name as orgName, count(t.id) as orgCount from SignUp t, Student s, Org o where t.studentId = s.id and s.orgId=o.id group by o.name) as result" 执行过程中，会报错：1234567891011九月 08, 2017 3:22:22 下午 org.hibernate.hql.ast.ErrorCounter reportError严重: line 1:61: unexpected token: countERROR 2017 09 08 15:22:22 com.opensymphony.xwork2.util.logging.commons.CommonsLogger.error(CommonsLogger.java:42) Exception occurred during processing request: unexpected token: ( near line 1, column 22 [select count(*) from (select o.id as id, o.name as orgName, count(t.id) as orgCount from com.lmscn.lms.model.SignUp t, com.lmscn.lms.model.Student s, com.lmscn.lms.model.Org o where t.studentId = s.id and s.orgId=o.id group by o.name) as result]; nested exception is org.hibernate.hql.ast.QuerySyntaxException: unexpected token: ( near line 1, column 22 [select count(*) from (select o.id as id, o.name as orgName, count(t.id) as orgCount from com.lmscn.lms.model.SignUp t, com.lmscn.lms.model.Student s, com.lmscn.lms.model.Org o where t.studentId = s.id and s.orgId=o.id group by o.name) as result] org.springframework.orm.hibernate3.HibernateQueryException: unexpected token: ( near line 1, column 22 [select count(*) from (select o.id as id, o.name as orgName, count(t.id) as orgCount from com.lmscn.lms.model.SignUp t, com.lmscn.lms.model.Student s, com.lmscn.lms.model.Org o where t.studentId = s.id and s.orgId=o.id group by o.name) as result]; nested exception is org.hibernate.hql.ast.QuerySyntaxException: unexpected token: ( near line 1, column 22 [select count(*) from (select o.id as id, o.name as orgName, count(t.id) as orgCount from com.lmscn.lms.model.SignUp t, com.lmscn.lms.model.Student s, com.lmscn.lms.model.Org o where t.studentId = s.id and s.orgId=o.id group by o.name) as result] at org.springframework.orm.hibernate3.SessionFactoryUtils.convertHibernateAccessException(SessionFactoryUtils.java:660) at org.springframework.orm.hibernate3.HibernateAccessor.convertHibernateAccessException(HibernateAccessor.java:412) at org.springframework.orm.hibernate3.HibernateTemplate.doExecute(HibernateTemplate.java:411) at org.springframework.orm.hibernate3.HibernateTemplate.execute(HibernateTemplate.java:339) at javacommon.base.BaseHibernateDao$PageQueryUtils.pageQuery(BaseHibernateDao.java:151) at javacommon.base.BaseHibernateDao$PageQueryUtils.access$1(BaseHibernateDao.java:147) at javacommon.base.BaseHibernateDao.pageQuery(BaseHibernateDao.java:121) 还是hibernate解析过程中出了问题，主要是对中间产生的result虚拟临时表没有办法识别，难道这就要放弃，只能使用JDBC来进行分页了？不然！经过思考，我们统计count的目的就是为了得到总数，也有一个折中的办法，如下：使用distinct进行去重，这样查到两条记录（也就是说共有两个单位），如下：1select count(distinct o.id) from t_sign_up t, t_student s, t_org o where t.student_id = s.id and s.org_id=o.id 转换成hql，如下：1String countQuery = "select count(distinct o.id) from SignUp t, Student s, Org o where t.studentId = s.id and s.orgId=o.id"; 结果如下： 可以看到，分页成功了： 2017-09-16-java去除HTML标签123456789101112131415161718192021222324/** * 过滤html标签 * @param htmlStr * @return */ public synchronized static String delHTMLTag(String htmlStr)&#123; String regEx_script="&lt;script[^&gt;]*?&gt;[\\s\\S]*?&lt;\\/script&gt;"; //定义script的正则表达式 String regEx_style="&lt;style[^&gt;]*?&gt;[\\s\\S]*?&lt;\\/style&gt;"; //定义style的正则表达式 String regEx_html="&lt;[^&gt;]+&gt;"; //定义HTML标签的正则表达式 Pattern p_script=Pattern.compile(regEx_script,Pattern.CASE_INSENSITIVE); Matcher m_script=p_script.matcher(htmlStr); htmlStr=m_script.replaceAll(""); //过滤script标签 Pattern p_style=Pattern.compile(regEx_style,Pattern.CASE_INSENSITIVE); Matcher m_style=p_style.matcher(htmlStr); htmlStr=m_style.replaceAll(""); //过滤style标签 Pattern p_html=Pattern.compile(regEx_html,Pattern.CASE_INSENSITIVE); Matcher m_html=p_html.matcher(htmlStr); htmlStr=m_html.replaceAll(""); //过滤html标签 return htmlStr.trim(); //返回文本字符串 &#125; 2017-09-16-java字符串保存到Mysql中文乱码问题最近遇到java中设置中文字符串到Mysql出现中文乱码问题。之前的数据库链接是：1jdbcUrl=jdbc:mysql://192.168.1.123:3306/mydb?zeroDateTimeBehavior=convertToNull 改成如下就好了：1jdbcUrl=jdbc:mysql://192.168.1.123:3306/mydb?zeroDateTimeBehavior=convertToNull&amp;useUnicode=true&amp;characterEncoding=utf-8 2017-09-16-java获取当天24点123456Calendar calendar = Calendar.getInstance(); calendar.setTime(new Date()); calendar.set(Calendar.HOUR_OF_DAY, 24); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); Date start = calendar.getTime(); 2017-09-16 Java 获取指定日期之前或者之后的多少分钟12345678910111213/** * 计算指定日期之前或者之后的多少分钟 * @param date * @param minute * @return */ public static String getTimeByMinute(Date date, int minute) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(Calendar.MINUTE, minute); return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(calendar.getTime()); &#125; 2017-09-16-java-获取编码转换为utf-8123456try &#123; address = new String(address.getBytes("ISO-8859-1"),"UTF-8");&#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 2017-09-16 微信消息解析用到的Java enum 枚举微信取得消息类型的时候会报错：1234567891011// 取得消息类型 String msgType = inputMsg.getMsgType();WXEventType.MsgType key = WXEventType.MsgType.valueOf(msgType);switch (key) &#123;case WXEventType.MsgType.event: break;default: break;&#125; 报错如下： 1The qualified case label WXEventType.MsgType.event must be replaced with the unqualified enum constant event 定义中是有的，如下：123456789101112131415161718192021222324252627282930313233343536373839// / &lt;summary&gt; // / 消息类型枚举 // / &lt;/summary&gt; public enum MsgType &#123; // / &lt;summary&gt; // /文本类型 // / &lt;/summary&gt; text, // / &lt;summary&gt; // / 图片类型 // / &lt;/summary&gt; IMAGE, // / &lt;summary&gt; // / 语音类型 // / &lt;/summary&gt; VOICE, // / &lt;summary&gt; // / 视频类型 // / &lt;/summary&gt; VIDEO, // / &lt;summary&gt; // / 地理位置类型 // / &lt;/summary&gt; location, // / &lt;summary&gt; // / 链接类型 // / &lt;/summary&gt; LINK, // / &lt;summary&gt; // / 事件类型 // / &lt;/summary&gt; event, // / &lt;summary&gt; // / 小视频 // / &lt;/summary&gt; SHORTVIDEO &#125;...&#125; 解决办法，删除WXEventType.MsgType，如下：1234567891011// 取得消息类型 String msgType = inputMsg.getMsgType();WXEventType.MsgType key = WXEventType.MsgType.valueOf(msgType);switch (key) &#123;case event: break;default: break;&#125; 2017-09-16-Java-Integer自增Java Integer 类的对象创建之后他的值就不能被修改，在 Integer ++ 的时候Integer是创建一个新的对象如果要自增，怎么办呢？可以这样：123private void test(AtomicInteger index) &#123; signUpStudentNum.getAndIncrement();&#125; 2017-09-16-JFinal传递map到JSP页面中 封装map 12Map&lt;String, Object&gt; responseInfoMap = new HashMap&lt;String, Object&gt;();responseInfoMap.put("testInfo", testInfo); 设置属性 12setAttr("commentListInfo", responseInfoMap);renderJsp("/WEB-INF/jsp/helloworld/hello.jsp"); JSP页面通过EL表达式获取 1$&#123;commentListInfo.testInfo.title&#125; 2017-09-16-JFinal使用WebSocket1、先建立一个Maven项目，如果是老项目，也可转成maven项目，参见我之前写的一篇帮助：Myeclipse普通java项目转maven项目 2、pom.xml引用相关jar包，1.7之后支持，配置如下：1234567891011121314 &lt;dependencies&gt;&lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; tomcat7和jave EE 1.7都支持，注意引用一个，不要重复。 3、编写事件拦截处理代码：ZhiWebSocketHandler.java123456789101112131415161718192021222324252627282930package com.yyxz.main;import java.util.regex.Pattern;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.jfinal.handler.Handler;import com.jfinal.kit.StrKit;public class ZhiWebSocketHandler extends Handler &#123; private Pattern filterUrlRegxPattern; public ZhiWebSocketHandler(String filterUrlRegx) &#123; if (StrKit.isBlank(filterUrlRegx)) throw new IllegalArgumentException("The para filterUrlRegx can not be blank."); filterUrlRegxPattern = Pattern.compile(filterUrlRegx); &#125; @Override public void handle(String target, HttpServletRequest request, HttpServletResponse response, boolean[] isHandled) &#123; // TODO Auto-generated method stub if (filterUrlRegxPattern.matcher(target).find()) return ; else &#123; next.handle(target, request, response, isHandled); &#125; &#125;&#125; 在JFinal Config中进行注册：12345678910public class DemoConfig extends JFinalConfig &#123;//... public void configHandler(Handlers me) &#123; me.add(new ContextPathHandler("ctx")); me.add(new ZhiWebSocketHandler("^/websocket"));// 也可以使用UrlSkipHandler，就不用编写Handler处理类了// me.add(new UrlSkipHandler("^/websocket", false)); &#125;//...&#125; 4、后台监听websocket代码：WebSocketController.java12345678910111213141516171819202122232425262728293031323334353637383940package com.yyxz.controller;import java.io.IOException;import javax.websocket.OnClose;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint;@ServerEndpoint("/websocket")public class WebSocketController &#123; public WebSocketController() &#123; System.out.println(" WebSocket init~~~"); &#125; @OnOpen public void onOpen(Session session) &#123; System.out.println("onOpen"); &#125; @OnClose public void onClose(Session session) &#123; System.out.println("onClose"); &#125; // @OnError// public void onError(Session session) &#123;// System.out.println("onError");// &#125; @OnMessage public void onMessage(String requestJson, Session session) throws IOException &#123; requestJson = "一一小知回复：" + requestJson; System.out.println(requestJson); session.getBasicRemote().sendText(requestJson); &#125;&#125; 5、在前端发起，编写页面：webSocketTest.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%@page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;!-- for HTML5 --&gt;&lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Welcome &lt;br /&gt; &lt;input id="text" type="text" /&gt; &lt;button onclick="send()"&gt;发送消息&lt;/button&gt; &lt;hr /&gt; &lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt; &lt;hr /&gt; &lt;div id="message"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var websocket = null; //判断当前浏览器是否支持WebSocket if ('WebSocket' in window) &#123; websocket = new WebSocket("ws://localhost:8080/yiyixiaozhi/websocket"); &#125; else &#123; alert('当前浏览器 Not support websocket') &#125; //连接发生错误的回调方法 websocket.onerror = function () &#123; setMessageInnerHTML("WebSocket连接发生错误"); &#125;; //连接成功建立的回调方法 websocket.onopen = function () &#123; setMessageInnerHTML("WebSocket连接成功"); &#125; //接收到消息的回调方法 websocket.onmessage = function (event) &#123; setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 websocket.onclose = function () &#123; setMessageInnerHTML("WebSocket连接关闭"); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function () &#123; closeWebSocket(); &#125; //将消息显示在网页上 function setMessageInnerHTML(innerHTML) &#123; document.getElementById('message').innerHTML += innerHTML + '&lt;br/&gt;'; &#125; //关闭WebSocket连接 function closeWebSocket() &#123; websocket.close(); &#125; //发送消息 function send() &#123; var message = document.getElementById('text').value; websocket.send(message); &#125;&lt;/script&gt;&lt;/html&gt; 结果如下： 2017-09-16-JFinal-Controller中forwardAction的使用请求转发使用forwardAction，请求参数会带过去，不要在请求中带参数，比如：1forwardAction("/api/test/toPage?openId=1"); 正确的写法是：1forwardAction(&quot;/api/test/toPage&quot;); 2017-09-16-js中的“中文汉字”传到到java端乱码问题解决使用的是高德地图，获取到中文地址后，传递到java端显示乱码，如何解决呢？1234567String address = getPara("address");try &#123; address = new String(address.getBytes("ISO-8859-1"),"UTF-8");&#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; 2017-09-16-Mac批量重命名文件统一给文件加前缀，示例如下：123456789101112131415bianxh:2 bianxh$ lltotal 264drwxr-xr-x 33 bianxh staff 1122 9 16 13:43 .drwxr-xr-x 9 bianxh staff 306 9 16 13:44 ..-rw-r--r--@ 1 bianxh staff 397 9 16 12:26 EL表达式，结果取整.md-rw-r--r--@ 1 bianxh staff 801 9 16 12:26 Eclipse-Java-EE-IDE修改web项目部署路径.md-rw-r--r--@ 1 bianxh staff 2607 9 16 12:27 小结：使用正则表达式提取时间中的数字.mdbianxh:2 bianxh$ for var in *.md; do mv "$var" "2017-09-16-$&#123;var%.md&#125;.md"; donebianxh:2 bianxh$ lltotal 264drwxr-xr-x 33 bianxh staff 1122 9 16 13:44 .drwxr-xr-x 9 bianxh staff 306 9 16 13:44 ..-rw-r--r--@ 1 bianxh staff 397 9 16 12:26 2017-09-16-EL表达式，结果取整.md-rw-r--r--@ 1 bianxh staff 801 9 16 12:26 2017-09-16-Eclipse-Java-EE-IDE修改web项目部署路径.md-rw-r--r--@ 1 bianxh staff 2607 9 16 12:27 2017-09-16-小结：使用正则表达式提取时间中的数字.md 还有替换啊什么的，一些高级用法，参见：https://my.oschina.net/musings/blog/380939 比如，假如文件名称中有多个后缀怎么办呢？如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869bianxh:一一小知的副本 bianxh$ lltotal 336drwxr-xr-x 32 bianxh staff 1088 9 16 14:04 .drwxr-xr-x 6 bianxh staff 204 9 16 13:59 ..-rw-r--r--@ 1 bianxh staff 6148 9 16 13:21 .DS_Store-rw-r--r--@ 1 bianxh staff 501 9 16 12:26 2015-09-16-git代码仓库如何迁移.md-rw-r--r--@ 1 bianxh staff 3149 9 16 12:26 2015-12-18-读笔记：公司高速发展是对团队最好的管理.md.md-rw-r--r--@ 1 bianxh staff 3014 9 16 12:26 2015-6-2-2-如何“有效地一对一会谈”.md.md-rw-r--r--@ 1 bianxh staff 7447 9 16 12:26 2016-09-16-OSChina git 代码fork及PR指南.md.md-rw-r--r--@ 1 bianxh staff 163 9 16 13:24 2016-09-16-空谷幽兰-第六章-登天之道-第二节.md.md-rw-r--r--@ 1 bianxh staff 2159 9 16 12:26 2016-1-10-吐槽招商银行营业厅，赞一下微信客服.md-rw-r--r--@ 1 bianxh staff 3898 9 16 12:26 2016-1-16-Hunt.md-rw-r--r--@ 1 bianxh staff 1854 9 16 12:26 2016-1-17：喜欢？电子书：纸质书.md-rw-r--r--@ 1 bianxh staff 3708 9 16 12:26 2016-1-25：新时代的企业架构师.md-rw-r--r--@ 1 bianxh staff 1298 9 16 12:26 2016-1-26：实践应当从业务需求出发.md-rw-r--r--@ 1 bianxh staff 1676 9 16 12:26 2016-1-28：图像压缩技术？Lena.md-rw-r--r--@ 1 bianxh staff 661 9 16 12:26 2016-1-28：项目经理？产品经理.md-rw-r--r--@ 1 bianxh staff 3076 9 16 12:26 2016-10-11-内置对象.md.md-rw-r--r--@ 1 bianxh staff 572 9 16 12:26 2016-12-1-空谷幽兰-第六章-登天之道-第三节.md.md-rw-r--r--@ 1 bianxh staff 2464 9 16 12:26 2016-12-5-坚持很难.md.md-rw-r--r--@ 1 bianxh staff 1298 9 16 12:26 2016-2-5-对OKRs粗浅的理解.md.md-rw-r--r--@ 1 bianxh staff 1129 9 16 12:26 2016-4-25：软件模块的3项职责.md-rw-r--r--@ 1 bianxh staff 2126 9 16 12:26 2016-4-27：我眼中“项目经理”需要知道的.md.md-rw-r--r--@ 1 bianxh staff 8678 9 16 12:26 2016-5-10-“深淘滩，低作堰”-华为公司的战略创新和机制创新.md-rw-r--r--@ 1 bianxh staff 760 9 16 12:26 2016-5-3-曲江海洋馆简游.md.md-rw-r--r--@ 1 bianxh staff 10040 9 16 12:26 2016-5-4-樊登速读-重新定义公司.md.md-rw-r--r--@ 1 bianxh staff 802 9 16 12:26 2016-6-14-端午节日小记.md.md-rw-r--r--@ 1 bianxh staff 422 9 16 12:26 2016-6-15：刺猬心态.md-rw-r--r--@ 1 bianxh staff 829 9 16 12:26 2016-6-16：球队思维.md-rw-r--r--@ 1 bianxh staff 1011 9 16 12:26 2016-6-19：没有什么不同.md-rw-r--r--@ 1 bianxh staff 6380 9 16 12:26 2016-7-6-OKR管理方法.md-rw-r--r--@ 1 bianxh staff 7415 9 16 12:26 2016-9-9-[焦英俊]-阿里巴巴店铺的十年技术演变之路.md.md-rw-r--r--@ 1 bianxh staff 8300 9 16 12:26 2017-2-1-每个程序员都应读的10本经典书籍.md.md-rw-r--r--@ 1 bianxh staff 8833 9 16 13:25 2017-4-1-JSP.md.mdbianxh:一一小知的副本 bianxh$ rename 's/\.md.md$/\.md/' *.mdbianxh:一一小知的副本 bianxh$ lltotal 336drwxr-xr-x 32 bianxh staff 1088 9 16 14:05 .drwxr-xr-x 6 bianxh staff 204 9 16 13:59 ..-rw-r--r--@ 1 bianxh staff 6148 9 16 13:21 .DS_Store-rw-r--r--@ 1 bianxh staff 501 9 16 12:26 2015-09-16-git代码仓库如何迁移.md-rw-r--r--@ 1 bianxh staff 3149 9 16 12:26 2015-12-18-读笔记：公司高速发展是对团队最好的管理.md-rw-r--r--@ 1 bianxh staff 3014 9 16 12:26 2015-6-2-2-如何“有效地一对一会谈”.md-rw-r--r--@ 1 bianxh staff 7447 9 16 12:26 2016-09-16-OSChina git 代码fork及PR指南.md-rw-r--r--@ 1 bianxh staff 163 9 16 13:24 2016-09-16-空谷幽兰-第六章-登天之道-第二节.md-rw-r--r--@ 1 bianxh staff 2159 9 16 12:26 2016-1-10-吐槽招商银行营业厅，赞一下微信客服.md-rw-r--r--@ 1 bianxh staff 3898 9 16 12:26 2016-1-16-Hunt.md-rw-r--r--@ 1 bianxh staff 1854 9 16 12:26 2016-1-17：喜欢？电子书：纸质书.md-rw-r--r--@ 1 bianxh staff 3708 9 16 12:26 2016-1-25：新时代的企业架构师.md-rw-r--r--@ 1 bianxh staff 1298 9 16 12:26 2016-1-26：实践应当从业务需求出发.md-rw-r--r--@ 1 bianxh staff 1676 9 16 12:26 2016-1-28：图像压缩技术？Lena.md-rw-r--r--@ 1 bianxh staff 661 9 16 12:26 2016-1-28：项目经理？产品经理.md-rw-r--r--@ 1 bianxh staff 3076 9 16 12:26 2016-10-11-内置对象.md-rw-r--r--@ 1 bianxh staff 572 9 16 12:26 2016-12-1-空谷幽兰-第六章-登天之道-第三节.md-rw-r--r--@ 1 bianxh staff 2464 9 16 12:26 2016-12-5-坚持很难.md-rw-r--r--@ 1 bianxh staff 1298 9 16 12:26 2016-2-5-对OKRs粗浅的理解.md-rw-r--r--@ 1 bianxh staff 1129 9 16 12:26 2016-4-25：软件模块的3项职责.md-rw-r--r--@ 1 bianxh staff 2126 9 16 12:26 2016-4-27：我眼中“项目经理”需要知道的.md-rw-r--r--@ 1 bianxh staff 8678 9 16 12:26 2016-5-10-“深淘滩，低作堰”-华为公司的战略创新和机制创新.md-rw-r--r--@ 1 bianxh staff 760 9 16 12:26 2016-5-3-曲江海洋馆简游.md-rw-r--r--@ 1 bianxh staff 10040 9 16 12:26 2016-5-4-樊登速读-重新定义公司.md-rw-r--r--@ 1 bianxh staff 802 9 16 12:26 2016-6-14-端午节日小记.md-rw-r--r--@ 1 bianxh staff 422 9 16 12:26 2016-6-15：刺猬心态.md-rw-r--r--@ 1 bianxh staff 829 9 16 12:26 2016-6-16：球队思维.md-rw-r--r--@ 1 bianxh staff 1011 9 16 12:26 2016-6-19：没有什么不同.md-rw-r--r--@ 1 bianxh staff 6380 9 16 12:26 2016-7-6-OKR管理方法.md-rw-r--r--@ 1 bianxh staff 7415 9 16 12:26 2016-9-9-[焦英俊]-阿里巴巴店铺的十年技术演变之路.md-rw-r--r--@ 1 bianxh staff 8300 9 16 12:26 2017-2-1-每个程序员都应读的10本经典书籍.md-rw-r--r--@ 1 bianxh staff 8833 9 16 13:25 2017-4-1-JSP.md 2017-09-16-MAC通过Microsoft-Remote-Desktop控制windows按键找回由于MAC默认将F1、F2等按键使用了。所以正常情况下，需要通过fn+F1、F2等实现正常windows系统上的按键效果。 这个按键功能如果要和windows体验一致，操作如下： 系统偏好设置–&gt;键盘： 但是发现还有F11、F12无法使用，比如在Chrome调试过程中，由于要使用F12键来调出开发者工具。解决办法如下： 好，我们来在Mac下远程连接Windows，打开Chrome浏览器试试： 2017-09-16-Mac-下安装Java-EE下载的是：sh文件123456789101112131415bianxh:java_ee_sdk bianxh$ sudo chmod +x ./java_ee_sdk-7-jdk7-macosx-x64-ml.shbianxh:java_ee_sdk bianxh$ ./java_ee_sdk-7-jdk7-macosx-x64-ml.sh This program requires DISPLAY environment variable to be set.Please re-run after assigning an appropriate value to DISPLAY.bianxh:java_ee_sdk bianxh$ DISPLAY=:0 ./java_ee_sdk-7-jdk7-macosx-x64-ml.sh Extracting the installer archive...Extracting the installer runtime...Extracting the installer resources...Extracting the installer metadata...Welcome to GlassFish installerUsing the user defined JAVA_HOME : /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/HomeEntering setup...SwixML 1.5 (#144) 2017-09-16-Mac-安装多个jdk踩过的坑我是先安装了jdk 8，然后安装了jdk7，通过命令可以看到，默认链接的是jdk812345678910bianxh:Versions bianxh$ which java/usr/bin/javabianxh:Versions bianxh$ ls -l /usr/bin/javalrwxr-xr-x 1 root wheel 74 9 22 2016 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javabianxh:Versions bianxh$ /usr/libexec/java_home/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Homebianxh:Versions bianxh$ java -versionjava version &quot;1.8.0_121&quot;Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode) 配置~/.bash_profile1234567891011121314export PATH=$&#123;PATH&#125;:/Users/bianxh/Library/Android/sdk//platform-toolsexport PATH=$&#123;PATH&#125;:/Users/bianxh/Library/Android/sdk//toolsexport PATH=$&#123;PATH&#125;:/usr/local/apache-tomcat-7.0.77/binexport JAMES_SRC_HOME=/usr/local/james-project/james-project# 设置 JDK 8export JAVA_8_HOME=$(/usr/libexec/java_home -v 1.8)# 设置 JDK 7export JAVA_7_HOME=$(/usr/libexec/java_home -v 1.7)export JAVA_HOME=$JAVA_7_HOME#alias命令动态切换JDK版本alias jdk7=&quot;export JAVA_HOME=$&quot;JAVA_7_HOME&quot;alias jdk8=&quot;export JAVA_HOME=$&quot;JAVA_8_HOME&quot;alias subl=&quot;&apos;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&apos;&quot;alias ll=&apos;ls -al&apos; 使用命令生效配置：1bianxh:Versions bianxh$ source ~/.bash_profile 现在查看：12345678bianxh:Versions bianxh$ java -versionjava version &quot;1.7.0_80&quot;Java(TM) SE Runtime Environment (build 1.7.0_80-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)bianxh:Versions bianxh$ /usr/libexec/java_home -v 1.7/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Homebianxh:Versions bianxh$ /usr/libexec/java_home -v 1.8/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home 以后就可以通过命令自由切换了，效果如下：12345678910bianxh:libexec bianxh$ jdk8bianxh:libexec bianxh$ java -versionjava version &quot;1.8.0_121&quot;Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)bianxh:libexec bianxh$ jdk7bianxh:libexec bianxh$ java -versionjava version &quot;1.7.0_80&quot;Java(TM) SE Runtime Environment (build 1.7.0_80-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode) 当然，如果用eclipse，注意修改JAVA_HOME，在~/.bash_profile中修改。 2017-09-16-mac-chrome-开发者工具-快捷键开发者工具：option＋command＋ijavascript控制台：option＋command＋j或者按option＋command＋c也可以打开 2017-09-16-Myeclipse普通java项目转maven项目1、先解决在项目上右键单击，没有出现Configure菜单的问题，因为此菜单的下级有Convert to Maven Project解决办法：window–&gt;Preferences–&gt;General–&gt;Capabilities–&gt;My Eclipse Standard Tools–&gt;Advenced，勾选如下两项： 2、转maven项目，自己输入12&lt;name&gt;yiyixiaozhi-maven&lt;/name&gt;&lt;description&gt;maven配置&lt;/description&gt; 3、以要使用websoket为例，添加依赖关系12345678910111213141516171819202122232425262728293031323334&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;yiyixiaozhi&lt;/groupId&gt; &lt;artifactId&gt;yiyixiaozhi&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;yiyixiaozhi-maven&lt;/name&gt; &lt;description&gt;maven配置&lt;/description&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 备注：自己也可以设定maven的配置文件,settings.xml 建立一个C:\Users\zqzx.m2\settings.xml，源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0"?&gt; &lt;settings&gt; &lt;localRepository&gt;~/.m2/repository&lt;/localRepository&gt;&lt;!--需要改成自己的maven的本地仓库地址--&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;local private nexus&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;local private nexus&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;&lt;/profiles&gt; &lt;/settings&gt; 下载成功了，如下： 2017-09-16-Mysql获取表中某个Datetime字段那天24点之前的数据1select * from t_class_info where date_format(now(),&apos;%Y-%m-%d-%H-%i-%S&apos;)&gt;=begin_date and date_format(now(),&apos;%Y-%m-%d-%H-%i-%S&apos;)&lt;=date_format(end_date,&apos;%Y-%m-%d-24-00-00&apos;) 关键是这句：1date_format(now(),&apos;%Y-%m-%d-%H-%i-%S&apos;)&lt;=date_format(end_date,&apos;%Y-%m-%d-24-00-00&apos;) 2017-09-16-Mysql-更新枚举enum类型表定义如下：12345678CREATE TABLE `t_seat` ( `id` bigint(20) NOT NULL, ... `type` enum(&apos;seat&apos;,&apos;passage&apos;) DEFAULT NULL COMMENT &apos;座位类型（座位、过道）&apos;, ... PRIMARY KEY (`id`), KEY `place_id` (`place_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;座位表&apos; 如果要更新type，使用如下语句：1update t_seat a set a.type = &apos;seat&apos; where a.type = &apos;&apos; 不能这么使用：1update t_seat a set a.type = &apos;seat&apos; where a.type is null 2017-09-16-Mysql-获取某个时间之后一段时间的方法1select * from t_class_info where place_id = 10 and date_format(now(),&apos;%Y-%m-%d-%H-%i-%S&apos;)&gt;=begin_date and date_format(now(),&apos;%Y-%m-%d-%H-%i-%S&apos;)&lt;=date_add(end_date, interval &apos;1 00:00:00&apos; day_second) 参考：MySQL：日期函数、时间函数总结 - ggjucheng - 博客园 2017-09-16-web开发入门之中文乱码假如jsp页面使用了utf-8编码。但是声明如下：1&lt;%@ page language="java" import="java.util.*" pageEncoding="ISO-8859-1"%&gt; 实际运行过程就会中文乱码问题，改成如下就好了：1&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt; 2017-09-16-Windows查看端口占用解决root账号无法登陆的问题：修改my-default.ini，重命名为my.ini，修改文件内容：12# basedir = C:\Program Files\MySQL\MySQL Server 5.7# datadir = C:\Program Files\MySQL\MySQL Server 5.7\data 在“C:\Program Files\MySQL\MySQL Server 5.7”下创建data文件夹管理员运行cmd，输入：mysqld -install，显示安装成功；再输入：net start mysql输入：mysqld –initialize –user=mysql –console 得到临时密码启动服务net start mysql；进入mysql命令下：mysql -u root -p，输入刚刚的密码；更新root密码：mysql&gt; set password for root@localhost = password(‘123’); 解决无法在局域网通过sqlyog客户端链接mysql server的问题：12mysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;; 重启mysql服务后生效。 2017-9-13-Ubuntu环境初始化安装Mysql并配置外网访问1、安装：1sudo apt-get install mysql-server 2.检查是否安装成功：1sudo netstat -tap | grep mysql 3.允许远程连接：1sudo vim /etc/mysql/my.cnf 把 bind-address这一行 注释掉，或者改为：bind-address = 0.0.0.0 4.重启 MySQL：12345netstat -tap | grep mysqltcp 0 0 localhost:mysql *:* LISTEN 23381/mysqld root@jdu4e00u53f7:/# service mysql restartmysql stop/waitingmysql start/running, process 25300 5.授权用户能进行远程连接：首先进入mysql命令行1234567mysql -u root -pmysql&gt; grant all privileges on *.* to root@"%" identified by "password" with grant option;Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; exitBye 输入root安装mysql时，password使用安装时候设置的root用户密码。然后执行： 最后用SQLyog测试一下： 假如要授权某个用户访问，方法如下：修改 Mysql-Server 用户配置mysql&gt; USE mysql; – 切换到 mysql DB Database changed mysql&gt; SELECT User, Password, Host FROM user; – 查看现有用户,密码及允许连接的主机 +——+———-+———–+ | User | Password | Host | +——+———-+———–+ | root | | localhost | +——+———-+———–+ 1 row in set (0.00 sec) mysql&gt; – 只有一个默认的 root 用户, 密码为空, 只允许 localhost 连接 mysql&gt; – 下面我们另外添加一个新的 root 用户, 密码为空, 只允许 192.168.1.100 连接 mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘root’@’192.168.1.100’ IDENTIFIED BY ‘’ WITH GRANT OPTION;或允许所有ip访问： mysql&gt; GRANT ALL PRIVILEGES ON . TO root@”%” IDENTIFIED BY ‘’; mysql&gt; – 当然我们也可以直接用 UPDATE 更新 root 用户 Host, 但不推荐, SQL如下: mysql&gt; – UPDATE user SET Host=’192.168.1.100’ WHERE User=’root’ AND Host=’localhost’ LIMIT 1; 2017-9-19-Mysql group by报错1Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column &apos;information_schema.PROFILING.SEQ&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 解决办法，去掉ONLY_FULL_GROUP_BY，重新设置值。 12select @@global.sql_modeset @@global.sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; 2017-09-16-微信公众号消息自动回复中文乱码问题设置servlet请求和响应为utf-8，如下：123456789HttpServletRequest request = this.getRequest();HttpServletResponse response = this.getResponse();try &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8");&#125; catch (UnsupportedEncodingException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace();&#125; 2017-09-16-小结：使用正则表达式提取时间中的数字Quartz任务中对于时间的设定，有一定的规则，比如：“05 39 21 27 8 ? 2017”从数据库取出来的时间格式不是这样的，是这样的：2017-08-17 10:55:00所以我们要提取其中的数字，代码如下：123// 分割符是 "-" 或 空格" " 或冒号 ":"String time = "2017-08-17 10:55:00";String[] times = time.split("[\\-:\\s]&#123;1,&#125;"); 结果如下： 对了，还需要反转，才能对上：123List&lt;String&gt; timesList = Arrays.asList(times);Collections.reverse(timesList);times = (String[]) timesList.toArray(); 如下： 什么？还缺一个问号？由于Arrays.asList(times);返回的是一个固定长度的List，这次要折腾一下了：12345678910111213String time = "2017-08-17 10:55:00";// 分割符是 "-" 或 空格" " 或冒号 ":"String[] times = time.split("[\\-:\\s]&#123;1,&#125;");List&lt;String&gt; timesList = Arrays.asList(times);List&lt;String&gt; flexibleTimesList = new ArrayList&lt;String&gt;();flexibleTimesList.addAll(timesList);flexibleTimesList.add(1,"?");Collections.reverse(flexibleTimesList);String[] resultTimes = new String[flexibleTimesList.size()];for (String str : flexibleTimesList) &#123; System.out.println(str);&#125;resultTimes = (String[]) flexibleTimesList.toArray(); 打印都出来了，如下：12345670055101708?2017 但是走到最后一句，结果报错：12Exception in thread &quot;main&quot; java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String; at com.test.hello.Main.main(Main.java:38) 为什么呢？因为toArray()返回的是Object[] java.util.List.toArray()，强转String[]有问题。改用如下的办法：1flexibleTimesList.toArray(resultTimes); OK了，看看结果： 最后，别忘了转换，如下：1234567StringBuffer sb = new StringBuffer();for(String str : resultTimes) &#123; sb.append(str + " ");&#125;// 干掉最后一个空格time = sb.toString().substring(0, sb.length() - 1);System.out.println("&#123;" + time + "&#125;"); 注：StringBuffer 比StringBuilder线程安全，比String +执行效率高，用这个连接字符串最合适。 打印结果如下，多余的空格也剔除了：1&#123;00 55 10 17 08 ? 2017&#125; 2017-09-16-定时获取微信的AccessToken使用Quartz 2.2.3开启定时任务，每个整点获取一次，如下：1234String jobName = "GetWeixinAccessToken";String triggerName = jobName;// 每个整点执行一次quartzManager.addJob(jobName, triggerName, WeixinAccessTokenJob.class, "0 0 */1 * * ?", wxAccesstokenManager); QuartzManager使用Spring注入：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284import java.util.Date;import java.util.List;import org.quartz.CronScheduleBuilder;import org.quartz.CronTrigger;import org.quartz.JobBuilder;import org.quartz.JobDetail;import org.quartz.JobKey;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.SchedulerFactory;import org.quartz.Trigger;import org.quartz.TriggerBuilder;import org.quartz.TriggerKey;import org.quartz.impl.StdSchedulerFactory;import org.quartz.impl.matchers.GroupMatcher;import org.springframework.stereotype.Service;@Servicepublic class QuartzManager &#123; public static SchedulerFactory schedulerFactory = new StdSchedulerFactory(); public void addJob(String jobName, String triggerName, Class jobClass, String cron, Object obj) &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); // 任务名，任务组，任务执行类 JobDetail jobDetail = JobBuilder.newJob(jobClass) .withIdentity(jobName).build(); jobDetail.getJobDataMap().put("obj", obj); // 触发器 TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder .newTrigger(); // 触发器名 triggerBuilder.withIdentity(triggerName); triggerBuilder.startNow(); // 触发器时间设定 triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(cron)); // 创建Trigger对象 CronTrigger trigger = (CronTrigger) triggerBuilder.build(); // 调度容器设置JobDetail和Trigger sched.scheduleJob(jobDetail, trigger); // 启动 if (!sched.isShutdown()) &#123; sched.start(); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * @Description: 添加一个定时任务 * * @param jobName 任务名 * @param jobGroupName 任务组名 * @param triggerName 触发器名 * @param triggerGroupName 触发器组名 * @param jobClass 任务 * @param cron 时间设置，参考quartz说明文档 */ @SuppressWarnings(&#123; "unchecked", "rawtypes" &#125;) public void addJob(String jobName, String jobGroupName, String triggerName, String triggerGroupName, Class jobClass, String cron) &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); // 任务名，任务组，任务执行类 JobDetail jobDetail= JobBuilder.newJob(jobClass).withIdentity(jobName, jobGroupName).build(); // 触发器 TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger(); // 触发器名,触发器组 triggerBuilder.withIdentity(triggerName, triggerGroupName); triggerBuilder.startNow(); // 触发器时间设定 triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(cron)); // 创建Trigger对象 CronTrigger trigger = (CronTrigger) triggerBuilder.build(); // 调度容器设置JobDetail和Trigger sched.scheduleJob(jobDetail, trigger); // 启动 if (!sched.isShutdown()) &#123; sched.start(); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 修改任务的触发时间 * @param jobName * @param triggerName * @param cron */ public void modifyJobTime(String jobName, String triggerName, String cron) &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); TriggerKey triggerKey = TriggerKey.triggerKey(triggerName); CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey); if (trigger == null) &#123; return; &#125; String oldTime = trigger.getCronExpression(); if (!oldTime.equalsIgnoreCase(cron)) &#123; /** 方式一 ：调用 rescheduleJob 开始 */ // 触发器 TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder .newTrigger(); // 触发器名,触发器组 triggerBuilder.withIdentity(triggerName); triggerBuilder.startNow(); // 触发器时间设定 triggerBuilder.withSchedule(CronScheduleBuilder .cronSchedule(cron)); // 创建Trigger对象 trigger = (CronTrigger) triggerBuilder.build(); // 方式一 ：修改一个任务的触发时间 sched.rescheduleJob(triggerKey, trigger); /** 方式一 ：调用 rescheduleJob 结束 */ /** 方式二：先删除，然后在创建一个新的Job */ // JobDetail jobDetail = // sched.getJobDetail(JobKey.jobKey(jobName, jobGroupName)); // Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass(); // removeJob(jobName, jobGroupName, triggerName, // triggerGroupName); // addJob(jobName, jobGroupName, triggerName, triggerGroupName, // jobClass, cron); /** 方式二 ：先删除，然后在创建一个新的Job */ &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * @Description: 修改一个任务的触发时间 * * @param jobName * @param jobGroupName * @param triggerName 触发器名 * @param triggerGroupName 触发器组名 * @param cron 时间设置，参考quartz说明文档 */ public void modifyJobTime(String jobName, String jobGroupName, String triggerName, String triggerGroupName, String cron) &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); TriggerKey triggerKey = TriggerKey.triggerKey(triggerName, triggerGroupName); CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey); if (trigger == null) &#123; return; &#125; String oldTime = trigger.getCronExpression(); if (!oldTime.equalsIgnoreCase(cron)) &#123; /** 方式一 ：调用 rescheduleJob 开始 */ // 触发器 TriggerBuilder&lt;Trigger&gt; triggerBuilder = TriggerBuilder.newTrigger(); // 触发器名,触发器组 triggerBuilder.withIdentity(triggerName, triggerGroupName); triggerBuilder.startNow(); // 触发器时间设定 triggerBuilder.withSchedule(CronScheduleBuilder.cronSchedule(cron)); // 创建Trigger对象 trigger = (CronTrigger) triggerBuilder.build(); // 方式一 ：修改一个任务的触发时间 sched.rescheduleJob(triggerKey, trigger); /** 方式一 ：调用 rescheduleJob 结束 */ /** 方式二：先删除，然后在创建一个新的Job */ //JobDetail jobDetail = sched.getJobDetail(JobKey.jobKey(jobName, jobGroupName)); //Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass(); //removeJob(jobName, jobGroupName, triggerName, triggerGroupName); //addJob(jobName, jobGroupName, triggerName, triggerGroupName, jobClass, cron); /** 方式二 ：先删除，然后在创建一个新的Job */ &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * @Description: 移除一个任务 * * @param jobName * @param triggerName */ public void removeJob(String jobName, String triggerName) &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); TriggerKey triggerKey = TriggerKey.triggerKey(triggerName); sched.pauseTrigger(triggerKey);// 停止触发器 sched.unscheduleJob(triggerKey);// 移除触发器 sched.deleteJob(JobKey.jobKey(jobName));// 删除任务 &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * @Description: 移除一个任务 * * @param jobName * @param jobGroupName * @param triggerName * @param triggerGroupName */ public void removeJob(String jobName, String jobGroupName, String triggerName, String triggerGroupName) &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); TriggerKey triggerKey = TriggerKey.triggerKey(triggerName, triggerGroupName); sched.pauseTrigger(triggerKey);// 停止触发器 sched.unscheduleJob(triggerKey);// 移除触发器 sched.deleteJob(JobKey.jobKey(jobName, jobGroupName));// 删除任务 &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * @Description:启动所有定时任务 */ public static void startJobs() &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); sched.start(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * @Description:关闭所有定时任务 */ public static void shutdownJobs() &#123; try &#123; Scheduler sched = schedulerFactory.getScheduler(); if (!sched.isShutdown()) &#123; sched.shutdown(); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 判断JobName是否在执行队列中 * @param jobName * @return */ public synchronized static boolean isJobExist(String jobName) throws SchedulerException &#123; boolean isExistJob = false; Scheduler scheduler = schedulerFactory.getScheduler(); for (String groupName : scheduler.getJobGroupNames()) &#123; for (JobKey jobKey : scheduler.getJobKeys(GroupMatcher .jobGroupEquals(groupName))) &#123; String tmpJobName = jobKey.getName(); String jobGroup = jobKey.getGroup(); // get job's trigger @SuppressWarnings("unchecked") List&lt;Trigger&gt; triggers = (List&lt;Trigger&gt;) scheduler .getTriggersOfJob(jobKey); Date nextFireTime = triggers.get(0).getNextFireTime(); System.out.println("[jobName] : " + tmpJobName + " [groupName] : " + jobGroup + " - " + nextFireTime); if (tmpJobName.equals(jobName)) &#123; return true; &#125; &#125; &#125; return isExistJob; &#125;&#125; 在Spring ApplicationContext注入后，才可获取bean，web.xml配置拦截如下：12345&lt;!--Spring ApplicationContext 载入 --&gt;&lt;listener&gt; &lt;!-- &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; --&gt; &lt;listener-class&gt;com.test.hello.ContextLoaderListenerOverWrite&lt;/listener-class&gt;&lt;/listener&gt; 拦截类是为了获取manager，然后存放AccessToken到数据库中。实现如下：123456789101112131415161718192021222324252627282930313233343536public class ContextLoaderListenerOverWrite extends ContextLoaderListener &#123; @Override public void contextInitialized(ServletContextEvent event) &#123; // TODO Auto-generated method stub super.contextInitialized(event); ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(event.getServletContext()); startGetWeixinAccessTokenJobs(applicationContext); &#125; /** * 开启整点定时任务 */ public void startGetWeixinAccessTokenJobs(ApplicationContext ctx) &#123; WxBean currentBean = Utility.getAccessToken(); WxAccesstoken currentToken = new WxAccesstoken(); currentToken.setAccesstoken(currentBean.getAccess_token()); currentToken.setExpiresIn(Integer.valueOf(currentBean.getExpires_in())); currentToken.setLastRequestTime(new Date()); QuartzManager quartzManager = (QuartzManager)ctx.getBean("quartzManager"); WxAccesstokenManager wxAccesstokenManager = (WxAccesstokenManager)ctx.getBean("wxAccesstokenManager"); WxAccesstoken dbWxToken = wxAccesstokenManager.findFirst(); if (dbWxToken == null) &#123; // 新增Token wxAccesstokenManager.save(currentToken); System.out.println("新增Token：" + currentToken); &#125; else &#123; // 更新Token currentToken.setId(dbWxToken.getId()); wxAccesstokenManager.update(currentToken); System.out.println("更新Token：" + currentToken); &#125; String jobName = "GetWeixinAccessToken"; String triggerName = jobName; // 每个整点执行一次 quartzManager.addJob(jobName, triggerName, WeixinAccessTokenJob.class, "0 0 */1 * * ?", wxAccesstokenManager); &#125;&#125; 获取微信AccessToken的办法如下：12345678910111213141516171819202122232425262728293031323334/** * 获取微信的AccessToken * @return */public static WxBean getAccessToken() &#123; WxBean bean = null; Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); params.put("grant_type", "client_credential"); params.put("appid", Constants.WEIXIN_APPID); params.put("secret", Constants.WEIXIN_APPSECRET); try &#123; String jstoken = HttpUtils.sendGet( "https://api.weixin.qq.com/cgi-bin/token", params); // String access_token = JSONObject.fromObject(jstoken).getString( // "access_token"); // 获取到token并赋值保存 ObjectMapper objectMapper = JsonUtils.createObjectMapper(); try &#123; bean = objectMapper.readValue(jstoken, WxBean.class); &#125; catch (JsonParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return bean;&#125; 对了，还有关键的部分，在这个Job里面每个整点更新AccessToken123456789101112131415161718public class WeixinAccessTokenJob implements Job&#123; public WeixinAccessTokenJob() &#123; &#125; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; //打印任务详情 System.out.println( "WeixinTokenJob:" + "-" + context.getJobDetail().getKey().getGroup() +"——"+context.getJobDetail().getKey().getName() +"——"+context.getTrigger().getKey().getName() +"——"+context.getTrigger().getKey().getGroup() + new Date()); JobDataMap jobDataMap = context.getJobDetail().getJobDataMap(); WxAccesstokenManager wxAccesstokenManager = (WxAccesstokenManager)jobDataMap.get("obj"); // Todo 使用wxAccesstokenManager来管理数据库存放的AccessToken &#125;&#125; 2017-09-16-使用JFinal添加数据报id异常使用Jfinal新增一条数据： new CommentRecord().set(“comment_time”, new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”).format(new Date())).set(“star_level”, starLevel).set(“comment”, commentText).save(); 结果报错如下： com.jfinal.plugin.activerecord.ActiveRecordException: java.sql.SQLException: Field ‘id’ doesn’t have a default value at com.jfinal.plugin.activerecord.Model.save(Model.java:424)…Caused by: java.sql.SQLException: Field ‘id’ doesn’t have a default valueat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1073)… 原因是数据库对应的Table表的主键id不是自增的，修改即可： 2017-09-16-使用jstl优化评论星标html代码评论需要加5颗星的功能，之前代码是这么写的： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;c:if test="$&#123;star_level == 1&#125;"&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;&lt;/c:if&gt; &lt;c:if test="$&#123;star_level == 2&#125;"&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;&lt;/c:if&gt; &lt;c:if test="$&#123;star_level == 3&#125;"&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;&lt;/c:if&gt; &lt;c:if test="$&#123;star_level == 4&#125;"&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;&lt;/c:if&gt; &lt;c:if test="$&#123;star_level == 5&#125;"&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;i class="ys"&gt;&lt;/i&gt;&lt;/c:if&gt;&lt;c:if test="$&#123;curentCommentRecord == null || star_level == 0&#125;"&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt;&lt;/c:if&gt; 是不是看着很冗余？如果是10颗星呢？那代码就更长了，也不好维护，看着不舒服，那咋优化呢？如下：12345678910&lt;c:forEach begin='1' end="5" var='item'&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;item &lt;= star_level &#125;"&gt; &lt;i class="ys"&gt;&lt;/i&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;i&gt;&lt;/i&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/c:forEach&gt; 效果出来了，棒棒哒。 2017-09-16-关于Tomcat自动加载更新class的小技巧在Tomcat的server.xml或者Tomcat.xxx\conf\Catalina\localhost\project.xml文件中里Context标签内： 第二步：debug方式启动Tomcat。如果你用的是eclipse Tomcat插件的话，将Don’t run tomcat debug mode取消勾选，就是将会是debug方式启动Tomcat了：window=&gt;preferences=&gt;Tomcat=&gt;JVM Settings 如果是MyEclipse: 2017-09-16-内网穿透使用frp进行内网穿透，可以很方便地进行调试，比如微信公众号。穿透前，需要有一台能连接公网的机器，京东云最近做活动，可以免费半年。我在这上面进行了实战。 原来用的是花生壳，但是有很多限制，还是自己弄了域名比较方便。 frp是什么，就不多说了，有兴趣的童鞋看这个：https://github.com/fatedier/frp 工具在上面的github地址上可以下载到，我提供一个X86 CPU版本的windows和linux版本的地址。链接：http://pan.baidu.com/s/1kV7R39t 密码：md3a 在公网IP服务器配置frps.ini，如下：123[common]bind_port = 7000vhost_http_port = 80 本地局域网配置frpc.ini1234567891011121314[common]server_addr = 111.61.131.13server_port = 7000[ssh]type = tcplocal_ip = 192.168.3.133local_port = 22remote_port = 6000[web]type = httplocal_port = 8080custom_domains = test.bianxh.top 公网使用的是Linux，运行命令如下：12345root@***:~/frp_0.13.0_linux_386# ./frps -c ./frps.ini2017/09/12 12:37:50 [I] [service.go:83] frps tcp listen on 0.0.0.0:70002017/09/12 12:37:50 [I] [service.go:108] http service listen on 0.0.0.0:802017/09/12 12:37:50 [I] [main.go:112] Start frps success2017/09/12 12:37:50 [I] [main.go:114] PrivilegeMode is enabled, you should pay more attention to security issues 本地是Windows，运行命令如下：1234D:\GreenSoft\frp_0.13.0_windows_amd64&gt;frpc.exe -c frpc.ini2017/09/12 12:35:00 [I] [control.go:276] [ded5c9fb0d273509] login to server success, get run id [ded5c9fb0d273509]2017/09/12 12:35:01 [I] [control.go:411] [ded5c9fb0d273509] [ssh] start proxy success2017/09/12 12:35:01 [I] [control.go:411] [ded5c9fb0d273509] [web] start proxy success 下来去服务商管理后台，配置下域名解析： 记录类型 主机记录 记录值 A test 公网IP，比如：111.61.131.13 可以访问到本地了：http://test.bianxh.top/yiyixiaozhi/webSocketTest.jsp和本地访问一样，如下： 刚刷新两次，就提示无法访问了，没有备案的域名果然不好使啊：http://illegalitydomain.jcloud.com/ 换个地址，使用端口访问了一下，是通的。 下来还是要乖乖备案去。]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的天空]]></title>
    <url>%2F2017%2F09%2F17%2F2017%2F2017-09-17-%E6%88%91%E7%9A%84%E5%A4%A9%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[吃完早餐，临时起意，查查年卡上有没有近处可以游玩的。 算是出去兜风，查到还真有个去处：八达岭水关。 为了路上消遣，背上本书。 路程不算太近，坐公交，走了段一小段京藏高速，将近2个多小时，到了水关。 这个地方，很早之前好像在电视上看到过一些负面新闻，说黑导游带团来这里，不是真正的八达岭。 今天天气不错，温度也合适。Feel也很Well。 在路上做了一点功课，这段是明长城，基于军事防御目的，戚继光督建。 当然还有一段我们都很熟悉的历史，就是上次我在铁路博物馆也看到过的，詹天佑当年修筑铁路时，发明了“人”字形道岔，克服直线距离1000米需爬升33米高程的筑路难题。 当年修的这段路，就能通往我的好友大宝老家，张家口啦。 旁边还有一个詹公故居，确切地说，是借住在当地的人家。进小院后发现门都被锁着，商贩竟在院内做些小生意。外面光线太强，看不清里面的布局。我想起了陋室铭中的名句：斯是陋室，惟吾德馨。 入门左攀，不久就能看到角度很高的一个陡坡： 不知是不是传说的好汉坡？不过长城这样的坡估计不少。这个坡度和08年爬华山时的千尺幢和百尺峡有一拼。这不，有个胳膊上纹黑的壮小伙，倒车着一步步下来，双手紧握护栏，双腿很有节奏地色色发抖。带着太明显的哭腔，说这要怎么办啊。。。周遭有美女呵呵打逗，他也是下不来架子了，干脆闭眼坐一会，下几个台阶，人生头一次发现自己这么的恐高。 前行举步维艰，身后美景连连。 以前修筑的时候，也真是不易，很多段青砖斜铺着，风吹日晒不掉，也是筑的稳固。 翻过下一个烽堠，就能看到水关的妙景了。能看到仿佛苍龙起伏于崇山峻岭之间，穿行于悬崖峭壁之上。 正所谓：城堡相连，烽燧向望，双面箭垛，拒敌万千。 景点广播对水关有此评价：春看山花烂漫，夏览草木蓊郁，秋观漫山红叶，冬游苍龙卧雪。 长城四季美如画，也许过俩月，也有机会以观秋色。 从水关下来，沿着高德地图导航前往回城招停点，行走了一个多公里，路途除却匆匆往来车辆，山里也甚是寂静，以至于我走着走着，不小心打扰到了3只野鸡的清净，咯咯地飞的老高，奔向火车道那边去了。 到了地图招停点之后，却也发现没有任何的指示。我都怀疑自己走错了地方，犹豫着前行了一小段，果然来了辆公交车，招手停。 应该有很多八达岭下来的游客，把车辆挤得满当当的。 虽是山路，司机开车稳当，售票大姐一口京片子，一路不忘各种提示，听着也是舒心。 因为过昌平，顺路也过了十三陵的神道：能看到图上的龙虎上吧？！ 左青龙、右白虎、前朱雀、后玄武。中国帝王的陵寝以明代保存最为完好。 然后我沿路走过了石牌坊、大红门、碑楼，石象生，龙凤门。 大红门巍峨矗立，碑亭四角，各有汉白玉华表一座，表顶各有异兽一尊，面南者称望君出。面北者称望君归。每座华表上共刻有四十一条龙。 神路郁郁葱葱，有望柱二尊，坐立狮二对，坐立獬豸二对，立卧骆驼二对，立卧麟麟二对，立卧马二对,持瓜盔甲将军二对，朝衣冠文臣像二对，朝衣冠勋臣像二对，北接三门六柱式的棂星门，也称火焰牌坊，俗称龙凤门。 听旁边一个导游说，路上神物600多年，最好不要照相，于是后来我就再没照了。 站在汉白玉石像前，细细观察，还是很震撼的。 不知觉，天色不早。背上简单的行头，打道回府。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春风十里之，奔跑吧、我的鞋垫]]></title>
    <url>%2F2017%2F09%2F16%2F2017%2F2017-09-16-%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[那个夜晚，跑步河滩，疲惫着的路途，趴踩着的鞋垫，如此执拗、不断翻卷，每步跑起时，抡腿往后的最高点，一毫米，两毫米，借力攀爬终于，顶到了他的脚踝终于，摆脱了沉闷的空间直到惯性，将它轻轻抛起跌落沙滩，被踩成片 百无聊赖、烈日蛰伏、静候余华过了许久河滩冲刷，清流扑面它挥洒流波和鱼儿嬉戏和虾蟹猜拳和卵石碰触随船儿靠岸 抬头，云间仰望向帆为什么，我们都来源于泥土，抽丝成棉却一方在水、两方在天。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-09-15-日志：百度ABC]]></title>
    <url>%2F2017%2F09%2F15%2F2017%2F2017-09-15-%E7%99%BE%E5%BA%A6ABC%2F</url>
    <content type="text"><![CDATA[今天有幸到国家会议中心参加了百度云智峰会，在门口略作停留，看了眼无人车。可惜就是摆在那里，不好玩。 进门安检，进入验票大厅，虽然之前有报名，但是没收到邀约短信，但还好现场对签到把关不严，也能灵活应对。 上楼，中间路过一些冰冷机箱，也可以说是一个高大上的人工智能计算设备，已经过了上学时对电脑机箱组装都热血沸腾的年代，好在我对这些冰冷的电子设备无感，一路过了几个展台，看到旁边能跳舞的机器人，我也觉得，唉，有点傻，作的不太好玩。 就跟上学时候，喜欢做后面的位置一样，我们哥几个很快就找了边上靠后的位置落座了，实在不能再往后了，往后就是中控了，中控美女帅哥们操作翻飞，在控制各路激光整齐划一地荡往躁动的人群。 跨差跨差5、4、3、2、1倒计时后，开题由张亚勤先生演讲，记得早年读李开复老师的《世界因你而不同》，其中提到了微软研究园园长张亚勤先生。今日终得见真人。嗯嗯，应该是当了好多年领导，是一个公众人物。呱唧呱唧，雄才大略地带领我们概览了ABC-量到质的变革主题。 场地大，近万人。屏幕宽，近百米。从左到右，ABC三段式开场，AI（智能系列）+BigData（数据智能系列）+ Cloud（网络资源系列），娓娓道来，照着ppt深度解读了一遍。也提到了福利部分，百度技术学院1万套免费AI Star礼包。这个我想大家下来都有空上去了解一下，登录上去学习学习新的课程也好。 然后是百度副总裁尹世明大侠夸夸地谈，中间手舞足左右在舞台游走，讲了传统云服务和ABC云服务的区别，传统云服务的特征是：C、技术驱动、最佳业务实践、成本节约、IT供应链；ABC云服务的特征是：ABC、业务驱动、业务快速迭代/训练、收入提升、合作伙伴。要点我觉得是一句话吧：最佳业务实践的周期在新的AI计算力下得以拆解和迭代。这个是原力。 尹大侠擅长演讲，中间合作伙伴男士上台来时也不忘拍拍对方肩膀，暗含鼓励。当然，女士的话，静静的远远看着就行。礼貌有佳。 搞大事情，是要有背书的，这不，万黑当中一点粉红时尚外装的Intel数据中心事业部部总裁美女上台来了，全程英文，听得我懵逼，不过好一点的是，at last，合作共赢，共创美好未来之类的英语，奇怪，这类话，语境都和熟悉，第一次听着懂了的同时，也觉得自然的很。如果要说有不同，这个美女的演讲能力超强，演讲过程一口气，中间不带断的，自如操控ppt，但好像就没看ppt，自顾自说。演讲者当如此也。Intel要CPU定制化。4季度yeoman和百度共同发布一个AI解决方案中心，奇怪的是，加了多余的几个词：面向中国用户的。 AI的核心能力：语音、图像、视频、AR/VR、自然语言处理、知识图谱、用户图像等等。 百度认为AI在我国当前形势下，在工业领域接下来会有所作为，先重磅发布了和浪潮搞的ABC一体机，然后叫来一个个国字号的领导站台，首钢、宝钢、风电等。现场演示了钢铁行业的智能检测结果，大大释放了人力，这个迎来了现场的第一次大面积掌声。然后就说给海上风电带来了变革，自动化预测和修复。可惜这个事情没说明白，自动化预测，我想就是传感器监测数据，自动化修复是怎么做到的？是自动化保养吗？ 可能时间短吧，都是蜻蜓点水，花开半朵呀。 接下来银联商务的一个高层来说明AI和互联网金融的一些化学反应，上来就丢下一个幽默梗，说知道大家都不愿意听他来讲话。。。可惜肢体语言和神态表达僵硬，梗没响，接卸来就硬着头皮，拿着稿子在那里年了，我见过的演讲不多，拿稿子来念的，是头一遭。 还有我的老东家的合作伙伴，华数一个女高层上来演讲，大概就是AI协助视频甄别。自己越说声音越颤，你这个时候就能感觉到，把场地交给你，压力那是杠杠地，中间说的想停了，尹副总没有接过去，就又硬着头皮说了一会。嗯，这个美女老总又历练了一次，相信下次面对万人空巷的场景也就不会怵了。 后来每个合作伙伴上台演讲，时间没完没了。我们几个在老大的带领下，就出去唠嗑吃饭去了。 回来就是下午场，百度摊子铺的大，下午6个分场（ABC基础技术与开放平台、家居与汽车智能、设备智能与物联网平台、视频智能技术与平台、智慧金融与金融安全、大数据与智能营销）同步开始，我们根据口味挑选了视频智能技术与平台。 一会儿，尹大侠过来了，搞现场签约，让大家看看瞧瞧。然后就是各个合作伙伴，套路都是主持人开头说百度AI赋能，然后请行业的领军企业总裁来讲讲，然后企业的老板就来讲自己公司的的情况了。基本上是借助这个平台再宣传下自己。自顾自说。这些大佬们头脑里都准备了一套套的词汇，总是能扯到自己想说的地方上来。比如：主持人说，AI赋能孩子的教育，以后再也不担心我**了。然后有请威创的创始人来讲讲，前两天刚听朋友聊起此人，以前找人投资，也是艰难，现在估值数以亿计了，当初不投的人，现在也还是就不能投了。也是最近人气很高。言归正传，话说这位老板在全国地图上标注了一下，自己的园所全国有4500所，然后自己要做一款还没做的产品，问问大家喜不喜欢啊，大概就是经过AI视频分析后，提取出来关键词，最后交叉验证。拿到有价值的信息，比如家长关心自己的孩子的一些数据。。。这位老板说着说着，就忘记问我们喜不喜欢的事情了。过一会竟然结束发言了。这个和上午大会有没有共性？你说，你是喜欢虎头蛇尾呢，还是慢慢预热的一个现场体验呢？中间我也看到屏幕上有些到一个叫红缨教育的公司吧，随手搜索了一下，这家公司有个口号：让教育赞美生命。。。哇呀呀，看着这句话，我咋就这么不舒服呢？ 还有CNR，这个可是我初高中时候，一直在听的央广台的技术支持方，女领导上来就说自己如何如何有个牌照，全国6家中的一家。就差跟上午华数的姐姐那样说了，我向百度提出几点要求。。。大家都是合作伙伴好不。 最后，几个首席技术科学家，说了说PCDN、主播连麦的一些技术。本人表达能力有限，按下不表。总之大家，记得PCDN加了个P2P，很便宜，主播连麦，可以双方互动，增加可玩性即可。 期间有没有我觉得做得好的？嗯，是人人视频。是不是我对程序员出身的CTO有天然的好感，也许吧？！小伙年轻，干练。先是以视频开头，效果相当棒，然后埋点引出百度AI的视频推荐功能。自己公司以前4个人搞了1个月也能做出来一个简单的推荐系统，但是还是投奔大厂，暗含不是无能力，是找寻自己的位置，话说人力成本贵不贵？时间成本贵不贵？成本节约，有舍有得。能做出来是一回事，有没有强大的工程能力是另外一回事。这个还是需要大厂背书的。 服务稳定、高可用、实时。这个是一个项目产品化之后的必由之路。 人人视频CTO跟我们也一起分享了一些和百度小伙伴合作的一些细节，有过去、有现在、有未来。每个阶段指标的调整和企业文化的定位都息息相关。嗯，要做一个好公司，先让咱们都要有点文化，有点理想，是不？CTO也在末位，面对脚前2米处 ，说了自己的梦想。很真诚。 无论放荡不羁，还是言谈木讷，只要心之所向，就该敬佩，不是吗？ 末了，记得领一个纪念品：百度云书包去。这个礼品，是我等屌丝的真爱啊。 百度AI Inspire，嗯，Inspire这个词，我想想，用的真好！]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Resume]]></title>
    <url>%2F2017%2F09%2F03%2F2017%2FResumeOfBian%2F</url>
    <content type="text"><![CDATA[[TOC] 卞晓辉的简历 团队合作能力强。在现有团队中担任技术/项目经理角色。从事需求分析，交互设计、UI设计、任务分解、开发计划制定与跟进相关工作。 基本情况河北工程大学 自动化 本科 2007年毕业男 34岁 西安 职业技术经理 项目经理 Android开发 工具Axure Project OminiPlan Git 技能 Java编程 6年 Android开发 4年 C/C++开发 2年 CET-4 联系方式15129281012 bxh7425014@163.com 点击查看我的博客站点 纸上得来终觉浅，绝知此事要躬行。 工作履历西安维拓 / 研发部经理、产品经理 / 2014.07 – 2017.08 工作内容： 技术调研+需求分析+技术方案落实+项目计划制定和跟进。 外部资源协调，内部开发推进。 内部团队锻造（6个小组，共20人。Android+iOS+设计+前端+测试+后端）。 单年交付6个项目，均为：客户端+服务端模式，涉及一点分布式。其中某个app用户量过5万。 成长： 技术：Java基础提高（泛型+并发+反射）、Oracle数据库、Https加解密技术、MVC框架。 团队协作：钉钉+Tower（Smart任务、文件协同）。 代码协同：Git。 持续集成：Jekins 番茄工作法：Okr考核方式。 项目履历： 三维云办公（2016.11 – 2017.7）（目标竞品：钉钉、今目标）； 三维之家（2016.08 – 2016.10）（目标竞品：京东到家、左邻右里）； 驻村工作队（2016.05 – 2016.09）； 两学一做（2016.05 – 2016.06）； 党政办公（2016.02 – 2016.03）； 公培博视（2015.12 – 2016.01）； 三维城市（2015.08 – 2016.02）； 便民服务网（2014.08 – 2016.01）； 项目描述：分布式管理系统，基于业务场景进行开发管理系统、前端显示系统、Android/iOS App。涉及的技术有： 服务端框架：Dubbo、zookeeper； 缓存：Redis； 消息中间件：ActiveMQ； 负载均衡：Nginx 视图框架：Spring MVC 工作流引擎：Activiti 持久层框架：MyBatis JS框架：JQuery 其他组件：Bootstrap、EasyUI 数据库：Oracle、MySql Web容器：Tomcat 7 云盘：Hadoop HDFS 职责履历： 2015.7-2016.2 Android App开发+项目管理 2016.3-至今 项目规划、需求分析（信息结构，数据库设计参考；功能结构）、原型设计、开发计划制定与跟进。 新技术调研与推进、团队锻造、项目敏捷。 点滴汇聚： Android：AIDL、Service、Viewpager、Fragment、TabHost、ListView、GridView、ScrollView。 Java：泛型、并发、反射、Spring IOP AOC、加解密（数字证书、数字签名、DES、RSA） 设计模式：工厂、代理、订阅、包装、适配、单例。 工具：Axure、Visio、Project、OmniPlan。 TCL集团工业研究院 / Android开发工程师 / 2010.05 – 2014.07 工作内容： 互联网智能电视app开发：视频播放软件、图库软件、Launcher。 上线产品（以芯片类型划分）：Hisi、Sis、MTK、Mstar、Realtek等相关智能电视。耗费精力最大+收获最多项目：芒果Tv - Launcher（我来主导开发+推进）。 成长： 功底提升：Java、C++。 设计模式：高内聚+低耦合，重设计+轻实现。 团队协作：主动、沟通、果断、大胆假设+小心求证。 代码协同：git。 职责履历： 互联网智能电视app开发：视频播放软件、图库软件、Launcher。 Android App开发，平均2人开发并维护一款应用。 项目描述： 基于Hisi、Sis、MTK、Mstar、Realtek等相关芯片平台智能电视预置Launcher的开发、升级与维护。 点滴汇聚： Android：Handler 、 Looper 、Message、Service、Binder、ServiceManager、WMS、View、SystemUI、WallpaperService。 Activity、Service、ContentProvider、Broadcast； Layout、OpenGL ES、JNI。 其他： 内存泄漏分析（C++、Java）、View布局拆解分析。 阻塞资源异步加载：网络（资源抓取）+本地（资源生成）。 自定义脚本。 西安天隆科技有限公司 / 单片机工程师 / 2007.7 – 2010.04 项目名称： PCR基因扩增仪，点击查看PCR基因扩增仪产品图 项目描述： 基于8051系列单片机，使用C语言进行程序开发温控程序。通过温控技术控制温度循环，实现聚合酶链式反应，达到检测目标。 职责范围： 硬件电路设计、PCB设计布板，电路调测，温控程序编写。 点滴汇聚： 单片机，AD/DA转换； 通信：RS232；CAN/I2C/SPI总线； MOSFET；三端稳压器7805和7812； PID控制； 半导体制冷片（PN结）原理； 项目成果展示成都干部网络学院（Java web项目）/2017.9 – 2018.1 角色：需求分析、产品设计、项目管理 PC管理端交互设计 PC学员端UI设计 移动管理端UI设计 移动学员端交互设计 双休日选学（微信公众号） / 2017.7 – 2017.9 角色：后端开发、接口开发。 项目简介：完成通过GPS的签到，及自动排座（类似影院选座）功能。 三维云办公OA（Web项目） / 2016.11 – 2017.05 角色：需求分析、交互设计、项目推进 产品原型初稿 PC端应用和管理平台。实现角色、权限的管理，以及所有产品内所有OA应用的入口。 点击查看效果图 测试环境地址。体验账号：18191762018 密码：123456。 三维云办公App考勤签到、考勤管理、自定义审批、云盘、日程和会议管理、Email服务、公告、任务、项目管理等。点击查看效果图 Android/iOS 移动端发布地址 三维之家/三维物业（移动端App）/ 2016.08 – 2016.10 简介：物业服务（缴费与维护）、最后一公里电商服务。 点击查看退货流程示意图 Web体验地址。账号：zd001 密码：456789 移动端发布地址：三维之家、三维物业，点击查看效果图 驻村工作队（移动端+Web） / 2016.05 – 2016.09 角色：需求分析、项目推进 Web端体验地址，体验账号：admin007 密码：vito123456 移动端发布地址 两学一做（移动端） / 2016.05 – 2016.06 角色：需求分析、Android app开发 简介：党章党规学习与测试、教育类视频播放、心得体会交流。 移动端发布地址 点击查看效果图 公培博视 / 2015.12 – 2016.01 移动端发布地址 ，体验账号：admin 密码：admin 三维城市 / Aandroid开发+项目推动+资源协调 / 2015.08 – 2016.02 简介：通过对接和整合资源服务兰州市民。涉及：社保公积金查询、社区信息查询、公交查询定位、公共自行车查询、便民办事指引等。 发布地址 移动端发布地址，体验账号：15129281012 密码：123456。点击查看效果图 便民服务网 / 项目推动+开发资源协调 / 2014.08 – 2016.01 发布地址。 TCL 芒果TV+ / 软件工程师+Launcher / 2014.03 – 2014.07 简介：类似于小米盒子Launcher，3D版本视频海报展示，TV画中画、App入口展示。实现重点：海报轮播动画（标题和海报同步切换），场景切换动画。 点击查看芒果TV Launcher效果图 3D海报轮播动画 / 实验项目 / 2012.11 – 2012.12 多幅海报在3D场景纵深排列，点击目标海报，切换到前排突出展示，其他海报按照旋转木马的效果走位到下一位置。 有意义的地方： 1、海报动画类实现（位置收敛算法来实现逐步逼近动画效果）。 2、OpenGL ES 3D场景鼠标射线拾取（视图变换、射线拾取）。 代码原理参考github上的思路。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的个人电脑采购史]]></title>
    <url>%2F2017%2F05%2F03%2F2017%2F2017-5-3-%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E9%87%87%E8%B4%AD%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[05年：第一台PC上大学时，大家伙都喜欢窝在宿舍看电视、电影、玩游戏，比如当我看到精神食粮（陈小春版的鹿鼎记）时，就宁可通宵达旦，那个感觉还是很爽的。那时宿舍每过晚上10点就会被楼下的大爷拉闸限电，因此如果谁能跟大爷搞好关系，网开一面，那时时相当有面子的一件事情。 电脑这么好，自己也的搞一个，所以我默默地对自己说：宁可饿肚子，也要把拥有自己的第一台计算机。 省吃俭用半年后，终于迎来了和好哥们去邯郸电脑城配电脑的一个阳光明媚的日子，CPU选性价比高的AMD、内存选大的、要配一个入门的独显就可以，当然也要一个能刻录机，其他的，键鼠套装、电源、机箱，便宜就好。 买来后也没怎么玩游戏，就玩过极品飞车9吧，最多的时候就是想着图书馆有那么多的电子资料，担心以后出去了就没有了，就一个个下载，刻录，还有一些大家的照片，也一个个从朋友拷贝，刻录。现在想来，那个时候不搞搞编程之类的，还是把电脑给瞎了。电脑没有拉网，就是天天研究WinXP系统的种种使用，什么注册表之类的，怎么编辑文档。那台电脑对我的帮助，仅仅在于放了一堆很多年就不会用到的电子电路、英语辅导类的电子资料。唯一一直被保存的，就是那时的一些照片。 当然，也带给我了一些技能，比如Protel 99SE的使用，Keil C51编程（当时没有单片机，仿真器和这个都是很贵的），就从网上找了模拟单片机的一些编程软件。那时不知道从哪里的途径了解到清华电子系的学生可以随便借用电子元器件来玩，心里那个羡慕啊。好学校就是好，我们就光天天学电子的这些个理论，没有实践，就功败一局。学校真是坑人，像我们这种内向的人，都不怎么受老师的搭理，学校的电子实验室，也不怎么有机会好好去玩。 毕业后，电脑运会农村老家，现在还在窑洞里面落灰呢，上次回家后，打开一下，虽然很卡，但是还能用，能帮老家的路由器做一些设置什么的，也还讲究能用。 第一个份工作都不知道是做什么的，就稀里糊涂进去做了一段时间，发觉不感兴趣，就再找，Protel上学时学的那点东西，还有上学时考的计算机2级C语言（那时没有电脑，是花了一个暑假，啃书硬上的）终于在07年底帮我找到了一份嵌入式开发的工作，工资不高，1200，能生存就可以。不奢求了。 07年：第一台笔记本后来毕业来到珠海，业余有大把的时间，看着大家都在KTV和玩桌球，我觉得不能荒废时间在这上面，就在发第3个月工资的时候，立即出手买了台神舟。07年夏天在珠海买的，珠海的夏天好炎热，宿舍的好友每到下班就往上撩妹，刷刷淘宝店铺，好不自在。 我眼看着工作跟上学所学的技术没啥关系，单位也不给大家配电脑，那还是自己搞个电脑，继续学学技术吧，这个也埋下了过当年11月份辞职的伏笔，辞职后，在珠海找了一星期的工作，都不知道从哪里找起，网上一查，看有个地方也许不错，想着直接去公司找找看，坐公交，到终点了，再走个几公里，到了厂子门口，发现有保安，也进不去，就只能悻悻而回了。当时也去过招聘会，看到珠海炬力电子，很牛逼，也很想去，投了简历，如石沉大海，当时mp3刚有点过火的样子，魅族的mp4正火。 不知道魅族在哪里，也没想到试试魅族。辗转了一个星期，宿舍也不能住了。和一起去的大家伙周末去了趟珍珠乐园，晚上在拱北吃了个饭，遂后就坐汽车到广州，坐火车回西安了。那时11月底，话说那时，刚回来后觉得西安真冷，在同学那住了一晚，第二天漫天白雪。然后就是07年的雪灾，火车也受影响，广州站聚满了人，庆幸自己早回来了两天。 那个冬天记忆中很冷，我在草场坡城中村住着，每天回家太冷，没有事情，就窝在被窝里面看美剧，印象最深的是看了“学徒（飞黄腾达）”，从第一季一直看下来，当然不曾想到，里面的大人物Trump后来有朝一日，成了美国当今的总统，大嘴炮的名声，在每集会议室等讨论中可见一斑。 同学陪着我到西安的火炬路，我做了面试之后，接下来的两天，在西电、西工大的校园招聘中寻找机会。有一次，正在我笔试之际，收到了火炬路那家公司的录用电话。万分高兴，开心。工资我都好像没问。不求别的，在西安，毕竟离家近一些啊。也就打消了年后再去深圳找机会的念头。 随后的日子和工作，每天都跟电脑打交道，都电脑的渴望也逐渐淡去。。。 17年：第一台MAC10年了，神舟的笔记本键盘换了一次。后来电脑跑不动了，就干脆束之高阁。娶了个老婆，附带送了个电脑（话说那个电脑还是我第一次认识她之后，10年在西安赛格配的，我自己对电脑的需求不是很强，当天买了一台ipad 1）反正在单位一样有电脑可用。对电脑的需求就不旺盛了。 上周，老婆的电脑突然罢工了。一下子没有电脑的处境，又让人无所适从。 苹果的ipad1使用到今，已经7年了。本来想着等今年的macbook air的升级版，既然事已至此，不想花功夫修已受损的PC了。那这次就咬咬牙，买台16版的macbook pro了。 适应了半天，立即觉得与此系统相见恨晚。立即感受到，这是一台绝对的生产利器。卖电脑的小伙，竟然说可以帮我免费安装windows 10（唉，我看着是像要买mac来装逼的人么？）。 鼓捣了两天环境，也安装好了Eclipse，做个代码测试，使用正则表达式来check Email邮箱地址的合法性。有兴趣的童鞋可以点击链接来访问哈。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清明时节]]></title>
    <url>%2F2017%2F04%2F04%2F2017%2F2017-04-04-%E6%B8%85%E6%98%8E%E6%97%B6%E8%8A%82%2F</url>
    <content type="text"><![CDATA[Success is not final, failure is not fatal: it is the courage to continue that counts.成功不是终点，失败也不是末日，持续前进的勇才是最重要的。 兴庆宫兴庆宫是唐玄宗做藩王时期的府邸，唐玄宗登基后大规模扩建，成为长安城三大内之一；是唐玄宗开元、天宝时代的中国政治中心所在，也是他与爱妃杨玉环长期居住的地方。 进入南门后不久，就可以看到一整片鲜艳的郁金香竞相开放，红色和黄色界限分明，甚是夺目。目前其他地方陆续有零星的白色和紫色的花蕾也已经形成，相比色彩斑斓的花的海洋再等几天就真的非常好看了。 郁金香的花语为博爱.体贴.高雅.富贵.能干.聪颖。红色代表热烈，黄色代表开朗，白色代表纯洁清高，紫色代表神秘和高贵。 郁金香这么好看，不知道大家是否还记得荷兰的郁金香危机么？这个多么让人可以无限畅想的花种啊。 唐苑中国唐苑盆景艺术起源于唐代，深受皇家的青睐。唐苑植入两万多棵几百年到上千年的古树。有灞桥垂柳、关中古槐、秦岭黑松、神农紫薇、千年银杏、百年皂角；也有供游人赏花品实的枇杷树、白玉兰、樱桃树和桃树、杏树。众多的树种枝繁叶茂，簇拥成林。 漫步期间，返璞归真之意不禁油然而生！唐苑收集了数以万计的巨石、奇石，形态各异、气象万千。唐苑虽然离城区近在咫尺，但彷佛与城隔绝。 杜陵杜陵位于西安市三兆村南，是西汉后期宣帝（即汉武帝的曾孙）刘询的陵墓。汉宣帝少时好游于原上，宣帝位后，遂在此选择陵地，建造陵园。陵墓处于高地，居高临下，极适合登高望远。 所以自汉代以来，杜陵一直是长安的游览圣地，文人学士常会集于此，登高览胜，并留下了许多诗篇。比如李白的《杜陵绝句》： 南登杜陵上，北望五陵间。秋水明落日，流光灭远山。 今天天气凉爽，我们沿路步行往上，荆棘绕陵，登顶北望，青翠欲滴。同家人朋友一路玩去，五步一景，正值桃李花开，也是很美观。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>清明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习]]></title>
    <url>%2F2017%2F04%2F01%2F2017%2F2017-4-1-JSP%2F</url>
    <content type="text"><![CDATA[1. JSP页面基本构成 1.1 JSP运行的4个关键阶段当浏览器向Web应用服务器请求一个JSP页面时，Web应用服务器将其转换为一个Servlet文件（即一个.java文件），然后将这个Java文件编译为一个字节码文件（即一个.class文件）。最后Web应用服务器加载转换后的Servlet实例，处理客户端的请求，并返回HTML格式的响应回应给客户端浏览器。 2. JSP指令标识JSP中包含了page、include和taglib共3个指令标识。 语法结构：1&lt;%@ 指令名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …%&gt; 2.1 页面指令page定义与整个JSP页面相关的属性，比如JSP页面的编码、内容类型及引用的类库等。 language属性：指定当前页面中使用的语言。 contentType属性：设置JSP页面的MIME类型和字符编码，浏览器会根据该属性指定的类型和编码显示网页内容。 pageEncoding属性：设置JSP页面的编码格式，在JSP页面中所有代码都使用该属性指定的字符集。 import属性：导入JSP页面中的类包，导入后在JSP页面中可以通过嵌入Java代码的方法使用这些类包。 buffer属性：设置out对象使用的缓冲区大小，默认为8 KB。 autoFlush属性：指定当缓冲区已满时自动将缓冲区中的内容输出到客户端，默认值为true。如果设置为false，当缓冲区已满时将抛出JSP Buffer overflow异常。 isErrorPage属性：将当前JSP页面设置为错误处理页面，以处理另一个JSP页面的错误，即异常处理。 errorPage属性：指定当前页面出现异常时调用的另一个页面（即错误处理页面），在错误处理页面中必须将isErrorPage属性值设置为true。session属性：指定当前JSP页面是否支持session。 isELIgnored属性：指定是否禁用EL表达式。 isThreadSafe属性：指定JSP页面是否是线程安全的。 2.2 文件包含指令includeinclude指令是静态包含，即被包含文件中所有内容会被原样包含到该JSP页面中。即使被包含文件中有JSP代码，在包含时也不会被编译执行。将两个页面组合成一个页面后编译处理，最后返回结果页面。 include指令的语法格式如下：1&lt;%@include file=&quot;path&quot;%&gt; 2.3 用引用标签库指令taglibtaglib指令用于声明一个标签的引用，在JSP页面之中声明了哪个标签库的引用，即可在JSP页面中调用哪个标签。该指令的语法格式如下：1&lt;%@taglibprefix=&quot;tagPrefix&quot;uri=&quot;tagURI&quot; %&gt; taglib属性：声明指令为taglib指令。 prefix属性：指定标签库的前缀。 uri属性：指定标签库文件的位置。 3. JSP脚本JSP中的脚本标识包括JSP表达式（Ex-pression）、声明标识（Declaration）和脚本程序（Scriptlet）。通过这些标识，在JSP页面中可以如编写Java程序一样来声明变量、定义方法或执行各种表达式的运算。 3.1 JSP表达式JSP表达式用于在页面中输出信息，它可以插入到网页的文本中用于输出文本内容，也可以插入到HTML标记中用于动态设置属性值。JSP表达式的语法格式如下：1&lt;%= 表达式%&gt; 3.2 声明标识在一个JSP页面中也可以如编写Java文件一样定义成员变量及成员方法，此种方式即声明标识的应用。使用声明标识在JSP页面中定义变量或方法是全局的，同时要求遵循Java语言的语法。声明标识的语法格式如下：1&lt;%! 声明变量或方法的代码 %&gt; 4. JSP动作标识在JSP规范中定义了一些标准的动作，用于为请求处理阶段提供信息。如操作JavaBean、包含其他文件和执行请求转发等，这些动作在请求处理阶段按照在页面中出现的顺序执行。由于JSP动作标识基于XML语法实现，所以在JSP页面中只需要遵循XML语法调用即可。JSP动作标识的通用语法格式如下：1&lt;标识名 属性1=&quot;值1&quot; 属性2=&quot;值2&quot;…/&gt; 或：1234&lt;标识名 属性1=&quot;值1&quot; 属性2=&quot;值2&quot;…&gt; &lt;子标识名 属性1=&quot;值1&quot; 属性2=&quot;值2&quot;…/&gt; … &lt;!--多个子标识--&gt;&lt;/标识名&gt; 4.1 包含动作标识动作标识用于包含其他页面，被包含的页面可以是动态页面或静态页面。包含的原理是将被包含的页面编译处理后将结果包含在页面中，包含页面的过程如图4.9所示。 当浏览器第1次请求一个使用包含其他页面的页面时，Web容器首先会编译被包含的页面。然后将编译处理后的返回结果包含在页面中，之后编译包含页面，最后将两个页面组合的结果回应给浏览器。 4.2 请求转发的动作标识动作标识将当前请求转发到其他Web资源（HTML页面、JSP页面和Servlet等），在执行请求转发之后当前页面将不再执行，而是执行该标识指定的目标页面。执行请求转发的基本流程如图所示。 动作标识的语法格式如下：1&lt;jsp:forward page=&quot;url&quot;/&gt; 或：123&lt;jsp:forward page=&quot;url&quot;&gt; 子动作标识&lt;jsp:param&gt;&lt;/jsp:forward&gt; page属性指定请求转发的目标页面，该属性值可以是一个指定文件路径的字符串或表示文件路径的JSP表达式。 4.3 子动作标识JSP的动作标识可以作为其他标识的子标识，用于为其他标识传递参数，其语法格式如下：1&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot; /&gt; 通过动作标识指定的参数将以“参数名=值”形式添加到请求中，其功能与在文件名后面直接加“?参数名=参数值”相同。 4.4 动作标识 使用动作标识可以在JSP页面中创建一个Bean实例，并且通过属性设置可以将该实例保存在JSP中的指定范围内。如果在指定的范围内已经存在指定的Bean实例，那么将使用这个实例，而不会重新创建。通过标识创建的Bean实例可以在Scriptlet中应用。 该标识的语法格式如下：123456789&lt;jsp:useBean id=&quot;变量名&quot; scope=&quot;page|request|session|application&quot; &#123; class=&quot;package.className&quot;|type=&quot;数据类型&quot;|class=&quot;package.className&quot; beanName=&quot;package.className&quot; &#125;/&gt;&lt;jsp:setProperty name=&quot;变量名&quot; property=&quot;*&quot;/&gt; 也可以在标识体内嵌入子标识或其他内容：1234567&lt;jsp:useBean id=&quot;变量名&quot; scope=&quot;page|request|session|application&quot; &gt; &lt;jsp:setProperty name=&quot;变量名&quot; property=&quot;*&quot;/&gt; &lt;/jsp:useBean&gt; 标识中各属性用法 id：定义一个变量名，程序中将使用该变量名引用所创建的Bean实例 type：指定id属性所定义变量的类型 scope：定义Bean实例的范围，默认值为page，其他可选值为rquest、session和application class：指定一个完整的类名，与beanName属性不能同时存在。若未设置type属性，则必须设置class属性 beanName：指定一个完整的类名，与class属性不能同时存在。设置该属性时必须设置type属性，其属性值可以是一个表示完整类名的表达式 4.5 动作标识属性用来从指定的Bean中读取指定的属性值并输出到页面中，该Bean必须具有getXXX()方法。 标识的语法格式如下：1234&lt;jsp:getProperty name=&quot;Bean实例名&quot; property=&quot;propertyName&quot;/&gt; 4.6 动作标识 标识通常情况下与标识一起使用，它调用Bean中的setXXX()方法将请求中的参数赋值给由标识创建的JavaBean中对应的简单属性或索引属性。该标识的语法格式如下： 123456789&lt;jsp:setProperty name=&quot;Bean实例名&quot; &#123; property=&quot;*&quot; |property=&quot;propertyName&quot; | property=&quot;propertyName&quot; param=&quot;parameterName&quot; | property=&quot;propertyName&quot; value=&quot;值&quot; &#125;/&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[17年读书计划]]></title>
    <url>%2F2017%2F02%2F01%2F2017%2F2017-2-1-17%E5%B9%B4%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[技术向前的步伐比人类历史上的任何时候都要走得更快。用不了几个月，就会有新的编程语言和工具问世，弥补现有语言、工具和方法的缺陷。事实上，许多伟人都已经遇到过差不多的问题，并指出了解决这些问题的最佳途径。而这些方法和解决方案都收录在一些超棒的书籍中。开发者们可以从下面列出的书中选择几本来阅读。 《程序员修炼之道》绝对是书籍中的瑰宝！这不是常规地建议你编码，编码还是编码的编程书。事实上，它并不限定于某种特定的编程语言：在这本书中的智慧适用于所有编程语言。这本书对许多有趣的领域都提出了真知灼见，如各种探索性编程，在代码中编码，从模型中分离的观点，昂贵的工具并不产生更好的设计，开发一个伟大的团队，管理预期，避免知识的重复等。这本书不仅可以帮助改变编码的习惯，还可以改变你作为一个程序员的性格。它充满了关于如何改进自己和代码的实用建议。还有一个总结了提示和检查清单的小册子。 《人月神话》非常经典，被奉为软件行业的圣经。第一次出版于 1970 年，但是里面的内容比起以前，可能更适用于现在！有听说过这些话吗？它们均摘自于这本书！“所有的程序员都是乐观的：一切都会顺利。”“添加人手到一个延迟的项目中只会导致完成得更慢。”“生一个孩子总是需要九个月的时间，不管安排多少个女性。”“一个煎蛋，承诺在两分钟内完成，但如果两分钟后还是没有准备好，那么客户有两种选择——等待或吃半熟品，软件客户也只能这样选择。”不幸的是，一年又一年地过去，而我们总是在软件开发中犯着相同的错误。这本书是每一个项目经理和开发人员都必须阅读的。 《代码整洁之道》有没有在看他人代码的过程中，不由自主地发出“哦，天哪，这是什么？”的经历，那么这个人肯定没有阅读过《Clean Code》。这是一本关于软件工艺史诗般的书籍。这本书不仅会告诉你如何编写好的代码，而且还提供了软件开发的高效途径。照着去做的话，必将改变你的工作前景。书中描述了编写干净代码的原则、模式和做法。里面一些关于整洁代码的几个案例都是开发人员宝贵的经验教训。请注意，虽然在这本书中的所有实例都是关于 Java 的，但是从中学到的经验教训可以应用于任意的编程语言。这篇文章所列出的这些书籍中，这本书出版得比较晚，所以可能更能引起年轻开发人员的共鸣。 《编码整洁之道》此列表中 Rob Martin 的第二本书。建议你在读了《Clean Code》后，再读这本书。《Clean Code》讲的是代码，而这本书是关于“Coder”。该书探讨了一些程序员经常忽视的主题。1、成为专业的程序员意味着什么？2、如何打磨自己成为一个真正的软件工匠3、冲突和紧张的日程处理4、如何管理你的时间？如何扩张技能？5、何时说“不”6、避免倦怠7、..以及更多。你可能并不总是同意作者的观点，但它提供了良好的精神食粮。这可能并非你所期望的，但可能正是你所需要的。 《重构》不管你怎么努力，除非改进它，否则，你交付的代码不会是最优化的。有时即使工作正常，也会实施重构。这本书从重构的通用原则说起：为什么以及什么时候重构，如何处理有关重构的管理等等。然后讲述了如何实现改进的过程。1、代码的设计缺陷指标是什么？2、如何构建类、方法和其他的逻辑块？3、单元测试4、如何将功能从一个对象移动到另一个？5、重构工具6、..以及更多这是改进现有代码必读的书。请注意，所有的代码示例用的都是 Java，但现在复制起来也很方便！ 《修改代码的艺术》我们都必须工作于一些我们痛恨的东西——对于大多数人而言，遗留代码真是令人头痛无比。如何修改遗留代码？如何识别需要重构的代码部分？如何破坏重构代码之间的依赖关系？如何确保新的代码能完成预期的工作？如何一次一小步地重构遗留代码？在这本杰出的书中，只是回答了一些关键的问题。如果非要用一句话总结这本书的精华，那就是“写单元测试，重构代码，确保测试都通过。”遗留代码不是一个神话，它是一个活着的传奇！在软件行业中没有什么比遗留代码更能经受测试的考验了——Deepak Karanth《代码大全》在一个庞大的作品中，如果你想要阅读所有关于编程结构和最佳实践的内容，那么这是本必读书。真正的百科全书式书籍——其最新版本有多达 960 页！不要被这本书的厚度吓倒，你可以按照自己的节奏阅读。最后，你会庆幸你阅读了这本书。书中解释了软件开发的每个方面。从代码结构，代码格式化，到变量、方法和类的命名，再一路说到管理一个团队，对所有一切都提出了实用的建议。提供了覆盖特定主题的丰富参考和补充材料，这些也非常值得一读。只有一小部分的软件开发人员会读这本书，所以如果你也是他们中的一个，那么你就有了优势。通过阅读这本书，你就可以获得许多年宝贵经验。 《Head First设计模式》看上去最不像技术的编程书籍！每个页面都包含涂鸦、图片以及其他一些吸引眼球的东西。可能给人的印象是一本阅读起来很轻松的书，但事实上它会讨论编程的一些核心主题——设计模式。这本书虽然没有覆盖所有存在于这个世界的模式，但是会涵盖所有你可能需要用于解决现实问题的模式。它将帮助你创建功能性的，优雅的，可重用的和灵活的软件。每个模式的优劣也被明确指出。大多数关于设计模式的书籍谈论的是如何实现模式，但这本书的作者同时还解释了为什么以及怎么样。最新版本包括针对 Java 8 的更新——主要是 Lambda。 《人件》很棒的一部作品。这本书并非关于编程。这是一本有关管理和激励程序员的书籍。开发人员也应该阅读。很多时候，开发人员，尤其是那些没有经验的开发人员，不理解管理的思维过程。软件开发是一个创造性的过程。但是，大多数管理人员把它当作是流水线。开发人员被视为是机器上可替换的齿轮零部件。管理人员普遍性地会给予一个紧迫的时间期限，当作促进积极性唯一途径。他们对开发人员的工作不感兴趣，甚至可悲的是，他们也不会试着去理解开发人员或他们自己的工艺。如果你想成为一个想要的是质量，而不仅仅是数量的管理人员，那么请立刻阅读这本书！作者解释了管理者应该如何以一种可持续的方式使他们的软件开发团队认识到他们的潜力。 《Soft Skills》同样的，这也不是一本关于编程的书。但是，却是每一个程序员都应该阅读的书。这本伟大的书着重于管理开发人员生活的“其他”方面。可以是你生活的每一个方面——事业、生活、身体、头脑，以及不管你相信与否——还有灵魂。作者他自己也遵循这些技术，并且获得了成功。他的网站上说，他能够在他 30 出头的时候放弃他的日常工作。该作者将他的生活经验整理成整齐的，主题内容为 Career、Marketing yourself、Learning、Productivity、Finances, Fitness 和 Spirit 的短章。每个篇章都很短，可以在休息时间阅读，非常方便。你会是一个更加满意和快乐的人，如果你按照这本书的建议去做的话，那么你将成为一个更令人满意和幸福的人和程序员。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2016日记]]></title>
    <url>%2F2016%2F11%2F08%2F2016%2F2016%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2016-6-19 没有什么不同 每个人都希望被这个世界温柔地对待，但是没有冲突，没有不满，没有人告诉你你其实很一般，很多时候我们就只会温柔滴待在原地，很多年。 就像有人给自己设定目标要学英语、学乐器、学编程、学设计、学会计、学书法、学厨艺最终一事无成一样，我骨子里也希望自己做个「样样精通」的「全才」，然而事实上自己把时间更多的花在收集信息和焦虑上，反而没有将时间用在真正的技能学习上，最终获得了「样样稀松」的结果。 我们每个人都没有什么不同，大多都都很平凡，所以不要一个人去战斗，我们行驶路上的目标不是消灭敌人，而是找到朋友，世界因多样所以不会无聊，尊重同行路上与我们意见相左的追梦人，帮助同行路上与我们志同道合的造梦人。也接受帮助，不要在乎对方的态度是坦诚相对，还是歇斯底里。很多人对于我们，亦师亦友。 2016-6-16 球队思维 好的公司应该比喻成一个球队。一个球队，场上打球的人可能工作年限完全不同，但不妨碍他们一样努力！ 当乔丹到芝加哥公牛队找工作的时候双方都绝对没有想过要合作一辈子，但乔丹和球队的目标是一致的。乔丹要成为最伟大的球员，球队要得冠军。这两者并行不悖。 大量的年轻人混日子是因为长期的应试教育让他们养成了被动型人格，这个问题能提醒他们工作最重要的目的是成长而不是加班费。 那么，怎么能把公司打造成球队呢？微信童鞋请订阅后阅读原文。简书童鞋请访问樊登 ｜ 你的公司是个大家庭还是个球队？ #2016-6-15 刺猬心态 工作上，当别人向你抛出一个问题，你是否第一反应是反击，还是先接纳问题，再进一步分析？ 如果反击成为习惯的话，那这样的不自信岂不又在脑海里默读并回顾了一遍，在自我编织的梦中沉醉了一次。多一次增加了伙伴的厌恶感，也别无他用了。 不乱于心，不困与情 不畏将来，不念过往 ——丰子恺 2016-6-14 端午节树下月间 剪韭做菜 日避云遮 擀面菜卷 乐意盎然 2016-6-2 人生三论人生最难的事，了解自己最简单的事情，给别人意见最快乐的事，拥有自己的目标，然后将它完成。 2016-5-3曲江海洋馆今天简单游览了曲江海洋馆，觉得海洋馆做的服务太一般。 先是进了海洋馆，因为人多，工作人员让排成两队，结果前面实际是排队看3D短片，先买3D眼镜。 然后蜡像馆，爬上2楼，才告诉要在门口买票。之前任何提示都没有。 出门时，全是卖玩具，抱一抱小鳄鱼拍照收费，送珍珠啥的就不说了。 极地馆也没太好，就是个玩游戏的地方嘛…… 最后压轴就是海豚表演，没有任何消音措施，个人觉得弄着消音海绵真心不错，主持人说的要表演啥，完全听不清。 2016-4-27 招聘项目经理做的一些准备 你读过哪些项目管理的书籍？分别有什么收获？ 你认为擅长哪些技术？在以往项目开发中，做过哪些贡献？ 一个项目的生命周期你如何理解？设计、开发、测试分别在哪些阶段会介入？ 用户需求分析、市场和竞品分析、产品功能架构设计等，输出并持续更新项目项目文档。 怎样协调项目生命周期中，测试和开发的关系？ 如何规划项目开发模板？ 怎样确定项目人员需求？ 怎样保证项目相关文档的持续更新（需求、接口、开发、测试）？ 如果客户不清楚需求（或者需求只是简单的一句话），甚至也不清楚对接的部门，但是要求你按照预定时间开发完成。你会怎么做？ 如果客户只是给了你对接的部门，然后告诉你，你去联系沟通需求，你会怎么做？ 如何计划、组织和控制项目工作，以实现预期目标。 借用什么方式和工具？思路是什么？ 如何对团队进行工作安排和督查？ 如果你发现自己的团队和其他合作团队中，有两个人工作上很不对付，你会怎么办？ 怎样保证项目计划和实施的同步，尤其是在需求频繁更新的情况下。 你认为一个合格的项目经理应该做哪些事情？ 你认为项目经理和产品经理的区别是什么？ 你认为怎样收集项目进展信息，不会让开发人员受干扰感觉更小（不排斥对工作进度的询问）？ 怎样进行项目汇报（包含哪些要素），能同时让领导和自己都满意？ 你会定期开展一对一沟通吗？哪些问题适合在此场合进行沟通？ 你会主持项目周例会吗？周例会一般开多久？目标是哪些？ 你会怎样协调客户、上级领导、团队成员、合作方之间的关系？ 你会怎样判断需求的优先级，在需求动态变化的过程中，你怎样重新调整团队人力以适应变化？怎样让开发知悉（避免过多抱怨），推动其调整开发计划？ 2016-4-23-游太平记 流水潺潺 枯木荫荫 行色匆匆 孔雀屏开 回心转意 紫荆花开，山花烂漫 般若星辰 清黄交接 青翠太平 瀑布烟霞 峰峦叠障 上下求索 静险中求 仙鹤逐潭 杜鹃花开 激流勇攀 雾里看花 风卷云舒 2016-2-5-对OKRs的理解O和KR的不同O指的是Objectives（目标），O是要是有挑战性的，如果是板上钉钉的事情就是不够的；KRs指的是Key and Results（关键结果），KR能很好的支持O的完成，是要明显可量化的，便于评分的。 Why？OKRs为了： 促使我们思考，主要目标会随之浮现； 沟通会更顺畅，让每个人都知道什么是最重要的； 能找到一个衡量过程的指标； 能让我们集中地为某件事而努力。 What？目标划分实施细则： 从上至下，目标的设立顺序应该是部门到组到个人。 部门需要制定年度和季度OKRs，组和个人需要制定季度OKRs。 O制定4-5个，每个O对应4-5个KR。 Who？关于考核： 每个季度末的的最后两周，部门会回顾本季度OKRs指标的完成度，并制定下一季度的计划。 OKRs是指导性的，并不是约束。但如果有人没有展示他的OKRs，部门经理和组长可以定期发邮件，列出黑名单。 每个季度末部门针对个人的任务完成度进行评分（评分并非越高越好）。 2016-1-28：项目经理？产品经理来源于《人员、流程和产品上的思考 - 读《启示录》总结》 产品经理产注的是定义有价值的产品。项目经理关注如何执行计划以交付产品。 互联网研发的角色包括：产品经理、用户体验设计师、项目管理人员、开发团队、运维团队、产品营销人员。 项目经理需要的能力： 工作紧迫感 善于捕捉问题 思路清晰 用数据说话 果断 判断力 态度（不能找延期的借口） 2016-1-26 实践应当从业务需求出发源自《服务化架构系统监控难题解决方案》，文章偏技术一些，InfoQ出品文章都比较耐看，有兴趣可以详读。 OPPO后端系统规模近几年快速发展，系统重构以后采用了服务化的架构，各系统之间耦合降低，开发效率得到了很大的提升。然而在服务化带来了好处的同时，难于监控的问题也一并出现。由于服务之间调用关系错综复杂，接口出现问题，多个系统报错，因此很难定位真正的故障源头。整个请求调用链就像一个黑盒子，无法跟踪请求的整个调用路径，发现性能瓶颈点。 从OPPO的自主研发监控系统的实践案例来看，一切应当从业务需求出发，目的是解决业务遇到的问题。面对开源软件的选择，要有所“为”，有所“不为”。业界有很多成熟的开源软件，也有一些比较大胆的设计思想可供借鉴，但开源软件并不是拿过来就能用好这么简单的，选择的原则可“管”可“控”。一个开源软件，如果不能“掌控”，不够简单，那就不如不用，自己用土办法也许反而会更好。 2016-1-25 新时代的企业架构师源自《架构师在精益企业中的角色是什么样的》 你知道架构中的哪些地方使用了比较老的技术，哪些地方比较脆弱，但是由于没有资源和时间去改变而不得不对现实妥协。那么如何实现这种转变呢？总体来看，企业架构师和其团队需要从传统的实践中进行转变。架构师将成为信息的影响者和聚合者，同时也是信息的传播者，其角色定位不再是自己做决定，而是帮助其他人做出正确的决定。 拥有并共享同一个愿景 在达成某种程度的共识之后，一定要让所有人都知道当前的架构和将来的架构分别是什么样子。这并不是说要将它们放到磁盘上的某个文件夹、SharePoint网站或者Wiki上，而是要制作海报或者一整面墙的涂鸦，在很多地方展示它们，确保每个人都能够了解该愿景，并激励他们不断地向该目标努力。在架构演进的过程中，这些图画也需要随之改变以反映当前的工作进展。要展示出那些正在提升的地方并认可为之付出的团队。如果其他人对一起构建伟大架构的工作感到自豪，那么他们就会支持你的工作。 建立桥梁 成功的企业架构师只能是那些能够取得开发团队支持的人。如果你将他们当作下属，他们就会找到应付你的方式，将组织愿景和战略至于危险境地，此时你依然需要对结果负责，却几乎没有改变的能力。相反地，如果你将他们当作合作伙伴，那么他们就会帮你实现愿景，所有人都会取得成功。要拥抱变化，衡量变化，确保每一个人都理解变化的价值，同时始终都应该尽量引导团队实现组织架构的愿景。 寻找改变的机会 耐心和合理的改变速度有助于避免挫折。记住，只能改变正在进行的工作，因此预算应该尽可能地包含大部分项目。通过识别那些能够为业务创造新价值或者节约更多金钱的新项目而不是通过节约开发成本来创造机会。要记住，产生业务价值是最主要的目标，因此要避免那些有趣却没有价值的、纯粹的技术项目。当业务认识到遵循愿景所增加的产量和价值，他们做出改变的势头和步伐就会加快。此时，就有机会继续塑造并精炼愿景了。 构建学习社区 不要试图自己决定组织需要的内容，应该建立一个技术小组，让技术领导和那些热衷于技术的开发者参与进来帮你做出决定。团队通过定期的会议制定相关计划。确保为开发团队预留一定的时间让他们分享自己的经验——无论是成功的还是失败的。让所有人都有机会与整个IT组织分享知识是一个健康的组织构建社区意愿的开始。 结论 改变从来都不是容易、快速的。向新的实践转变需要时间和努力，但最终你会发现这是值得的。当团队能够一起协作创造价值，业务将IT看做是合作伙伴而不是负担的时候，所有的一切都是值得的。记住，一个精益企业的架构师能够让开发团队和业务部门建立合作关系，能够创建一个愿景并引导开发团队向该愿景努力。知识虽然不是很深入但是却很广泛，能帮助开发者提高自己，能通过明智的实验进行概念验证。最重要的是，懂得享受自己，能够学习新事物并创造价值，能让组织成为业界领先的创新者。 2016-1-17 电子书or纸质书读电子书？读纸质书？请看：《为什么你只想读电子书？》 我就是不喜欢读纸书。这个后果会导致你错过太多没有电子版的好书，而好的内容和知识的积累，会彻底改变你的生活。 我就是不习惯用微信。那你就去用 QQ 和 MSN 好了，哦，对不起 MSN 已经从这个世界上消失了。而你会错过微信这个巨大生态的成长和构建过程，其中蕴藏的改变命运的机会何止千万。 我就是不爱写公众号，太封闭了。那你就会错过锻炼写作能力的机会，并与可能的成千上万的读者擦肩而过。 我用不惯 Mac。那你就去用 Windows 和 Linux 就好了，反正用好了也不会损失太多。 我是不会碰理财产品的。那你就等着货币贬值吧，或者，把资金扔到股市里，那里大开大合，大起大落，也许更符合你的人生信条呢。 人们在成长的过程中，会逐步确立自己的世界观和行事规则，在某个阶段，他们会按照自己建立的规则做事，做自己认为对的事，不逾越自己设置的底线，改变那些能改变的，接受那些不能改变的，不断前行，并且在前行的过程中建立新的规则，周而复始，直到我们离开这个世界。一个人的能力和心智越强，他的规则就越稳定，独立思考的能力也异于常人。对于高手来说，这些规则差不多可以用固若金汤来形容，几乎不会受到外界的影响。高手不可培养，只能自我成长，大概就是这个道理。 2016-1-16 看纪录片：Hunt好久都没有看记录片了，今天终于有空享用了BBC的大作-Hunt。第1、2集的精彩镜头摘录如下： 2016-1-15-关于烂代码的那些事《关于烂代码的那些事 － 为什么每个团队存在大量烂代码》 一个人工作了几年、做过很多项目、带过团队、发了一些文章，不一定能代表他代码写的好；反之，一个人代码写的好，其它方面的能力一般不会太差。 你是不是经常会碰到那些烂代码？ 意义不明 不说人话 不恰当的组织 缺少抽象 所以你想重构？从技术上来说，重构复杂代码时，要做三件事：理解旧代码、分解旧代码、构建新代码。而待重构的旧代码往往难以理解；模块之间过度耦合导致牵一发而动全身，不易控制影响范围；旧代码不易测试导致无法保证新代码的正确性。 同时重构的复杂度跟代码的复杂度不是线性相关的。比如有 1000 行烂代码，重构要花 1 个小时，那么 5000 行烂代码的重构可能要花 2、3 天。要对一个失去控制的工程做重构，往往还不如重写更有效率。 与写出烂代码不同的是，想写出好代码有很多前提： 理解要开发的功能需求。 了解程序的运行原理。 做出合理的抽象。 组织复杂的逻辑。 对自己开发效率的正确估算。 持续不断的练习。 所以，作为程序员来讲：不要奢望其他人会写出高质量的代码。不要以为自己写出来的是高质量的代码。 你我，都需努力。 2016-1-10 吐槽招商银行营业厅，赞一下微信客服前公司的工资卡是招行卡1，现公司的工资卡是招行卡2。朝朝盈只能在个人名下的一个卡上使用，卡1已经开过了，因此卡2无法使用此功能。想要用这个，就干脆注销卡1。同时我不想名下持有一个银行多张卡，旧卡1不发工资就会产生管理免费等，于是我去招商银行营业厅去办理卡更新业务。 诟病1：新政后，一人名下只能申请一次免费减免，旧卡已收回，意味着新卡2以后可能会面临年管理费用。。 后来跟微信客户聊天了，有减免的办法。看了营业厅的人员也是知道的情况不统一。需要培训培训了。方法如下：进入招行主页www.cmbchina.com 点击右侧“个人银行大众版”，输入卡号、查询密码后登录，进入网银大众版后请点击横排菜单“账户管理”-“账管费减免查询”选项，通过打开的界面即可查询、设置或修改减免账户。结果如下，大家自己就可以修改了： 诟病2：旧卡的一网通用户手机号无法修改，我先销卡，接着就没法换手机号了。这意味着一网通就无法使用了。 晚上从招商银行微信公众号找卡取消关联的方法，意外地和公众号客服聊上了。发现一网通绑定手机号竟然可以修改。后门在这里 https://user.cmbchina.com 诟病3：微信公众号关注了招行，已经进行了账号关联，现在竟然无法解除关联后再次关联。怎么破？ 从招行微信客服得知：2015年9月22日起，招行对微信银行一卡通绑定相关功能进行了调整，新用户或解绑后的用户将不提供“微信银行绑定功能”(对于调整前已绑定的客户不受影响)。如果您需要免费的动账通知，欢迎您下载我行手机银行最新版本。 招行为了扩展办卡数量，让我浪费资源。忙活了一个下午，还有营业厅的多个工作人员。 我想说，还我一下午浪费生命的时间。。。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS内置对象]]></title>
    <url>%2F2016%2F10%2F11%2F2016%2F2016-10-11-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[内置对象及其应用场合JSP内置对象是应用JSP进行Web开发时，通过它们可以对Web开发中的请求、响应、会话、应用、输出、配置信息和异常信息等内容进行控制。 request对象该对象封装了由客户端生成的HTTP请求的所有细节，主要包括HTTP头信息、请求方式和请求参数等。 在开发Web应用时经常应用request对象获取请求参数的值和获取Cooike数据等。 举例：1&lt;a href=&quot;delete.jsp?id=1&quot;&gt;删除&lt;/a&gt; 在delete.jsp页面中可以通过request对象的getParameter()方法获取传递的参数值，代码如下：1&lt;% String id=request.getParameter(&quot;id&quot;);%&gt; 执行了getParameter()方法后变量id的值为1。 request对象获取客户端信息的常用方法 getHeader(String name)获得HTTP协议定义的文件头信息 getHeaders(String name)返回指定名称的request Header的所有值，结果是一个枚举型的实例 getHeadersNames()返回所有request Header的名称，结果是一个枚举型的实例 getMethod()获得客户端向服务器端传送数据的方法，如get、post、header和trace等 getProtocol()获得客户端向服务器端传送数据所依据的协议名称。 getRequestURI()获得发出请求字符串的客户端地址，不包括请求的参数。 getRequestURL()获取发出请求字符串的客户端地址。 getRealPath()返回当前请求文件的绝对路径 getRemoteAddr()获取客户端的IP地址 getRemoteHost()获取客户端的主机名 getServerName()获取服务器的名字 getServerPath()获取客户端所请求的脚本文件的文件路径 getServerPort()获取服务器的端口号 request.getCookies()获取客户端保存的Cookie数据 response对象该对象适用于响应客户端请求信息. 开发Web应用时经常应用response对象重定向网页、设置HTTP响应报头和缓冲区配置等。 session对象该对象适用于在同一个应用程序中每个客户端的各个页面中共享数据。 session对象通常应用于保存用户/管理员信息和购物车信息等。 application对象该对象适用于在同一个应用程序中各个用户间共享数据。 通常应用在计数器或是聊天室中。 out对象该对象适用于向客户端输出各种类型的数据。 通常用来在JSP页面中输出文本。 page对象该对象适用于操作JSP页面自身。 在开发Web应用时很少应用。 config对象该对象适用于读取服务器的配置信息。 exception对象该对象适用于操作JSP文件执行时发生的异常信息。 pageContext对象该对象适用于获取JSP页面的request、re-sponse、session、application和out等对象。 由于这些对象均为JSP的内置对象，所以在Web应用开发时很少使用pageContext对象。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读：阿里巴巴店铺的十年技术演变之路]]></title>
    <url>%2F2016%2F09%2F09%2F2016%2F2016-9-9-%E8%AF%BB%EF%BC%9A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BA%97%E9%93%BA%E7%9A%84%E5%8D%81%E5%B9%B4%E6%8A%80%E6%9C%AF%E6%BC%94%E5%8F%98%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[阿里巴巴店铺的十年技术演变之路 阿里巴巴所提倡的 “大中台，小前台”战略是非常先进的业务打法，这个策略对技术的挑战其实更大！ 文章作者是全程网络CTO焦英俊，前阿里巴巴资深技术专家，1688总架构&amp;垂直开放平台负责人&amp;云电商平台创始人。 阿里店铺到10年经历了4个大的主版本。 店铺系统的挑战挑战划分为三大维度的问题：全平台、垂直化、个性化。 全平台：PC端、App端、Wap端，三端统一。我来举个实际例子，某一天业务人员找到技术说下个月要搞促销，我们希望在指定一批商家的店铺上投放特定优惠券，希望每个端都能同步投放，怎么破？ 垂直化：电商领域其实非常广泛，你不可能要求做原材料的行业和做快消品的行业是一样的体验。那会出问题，举个例子，原材料就是需要大量的规格展示，越专业越好；快消品主打营销，希望更多的营销主题；甚至某些企业还想提供独立的官网来提供企业的知名度。面对不同行业，不同诉求，这势必要求系统具备垂直化的能力来应对。 个性化：这个更容易理解了，每个商家都希望自己的店铺和其他人是不一样的，都有自己的特色！千人千面。 店铺的中台架构策略模块化策略首先，我们一起看下这张图片，大家应该都非常熟悉。商品陈列信息，阿里内部称为offer橱窗。 逛过电商网站的同学应该知道，这么个看似简单的内容，会有非常多的呈现方式，常规的都能数上很多，更不用说个性化的方式。 粗略的分析一下： 页面元素：图片、价格、订购 数据元素：大图（需要筛选出来合适的尺寸，阿里为了图片的美观做了多次的优化，目前可以做到按需加载不同尺寸的图片）、价格（是否有活动、折扣、会员价）、订购按钮（有没有权限，有没有库存） 显示要求：平铺 从这三点要求上来看，可以看出，这个小板块背后的逻辑还是比较复杂的。以前我们怎么做？ 第一个版本：硬编码，开发写了一个web control里面调用各种service，模板也单独写了一个（那个恐怖的时代，我印象中，页面超级复杂，大量的页面、JavaScript逻辑是copy出来的，轻易不敢维护），这个版本应该持续了有5、6年，相当痛苦。 第二个版本：control层widget，当时的架构师花了大量的时间构建了基于widget模式的系统。后端的逻辑看起来优雅了下一些，但是前端依然是全部写在一个页面当中的。当时web的同学最大的担忧就是发布，一个小小的VM都能引发一个p1故障。这个状态大概持续了3年左右。 第三个版本：组件化，页面层的种种问题积累了太多的血淋淋的教训！当时团队实在忍受不了了，决定全面实施组件化，加强了前端层面分组件开发的模式。这个是个巨大的进步，但是没有持续到半年就发现新问题了！整个系统设计的复杂度非常庞大（学院模式的过度设计），加上阿里惯性的拥抱变化，最后无人可维护。同时没有办法支持多个站点的需求，只能解决单一店铺。这个版本最后持续了一年多的时间。 第四个版本：模块化！简单的来描述就是前端组件化＋后端组件化，当然这里需要遵循同一个组件协议！开发人员也无需关心是在前端渲染还是后端渲染，这里最重要的点是让前后一致了，下面我们再具体介绍一下。 “前后端一致”的组件化 除了布局，当然还有一些其他技术的细节，比如校验、session管理、异步通信等，这里不再描述。最后看一个页面的案例。 统一数据中心 整个子系统由数据容器以插件的形式运行于客户端，它管理着数据资源，每个dataProvider对应一种数据源，它通过两种方式来获得外部数据。 一种是通过查找serviceInfo资源，然后基于其配置，以Dubbo协议（泛化调用方式）或HTTP协议的方式获取。 另一种通过本地服务调用的方式获取，接着根据dataStore中的业务代码（source.groovy）来聚合及处理这些数据服务的返回结果，并最终将获取的数据提供给app使用，完成app的取数与渲染，呈现在所有基于店铺平台客户端的应用页面之中。 开放的设计平台在核心技术日趋完善的情况下，我们发现生产力依然低下，因为我们要开发的业务需求还是非常多，虽然大家的开发效率已经得到大幅度的提升！ 但是还是会出现乱拳打死老师傅的情况，面对日益增长的个性化需求，我们选择了开放，将店铺核心体系开放出去，接入设计师来帮助我们完成个性化部分！ 这其实也是典型的云服务开放的案例，通过设计平台，我们既解决了自身的资源问题，又养活了40多个设计师！ 最后店铺业务只需要1-2个人日常维护就可以满足不断增长的业务需求！ 店铺生态建设围绕着平台核心技术的打造过程，我们自然逐步完成连接开发者、设计师、第三发开发者、运营人员，他们都可以很好的工作在店铺平台中完成各自的需求。整个店铺业务形成闭环，自然高效的工作在一起！]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读：自定义LyricView实现歌词显示控件]]></title>
    <url>%2F2016%2F09%2F02%2F2016%2F2016-9-2-%E8%AF%BB%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89LyricView%E5%AE%9E%E7%8E%B0%E6%AD%8C%E8%AF%8D%E6%98%BE%E7%A4%BA%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自定义LyricView实现歌词显示控件 | 源码地址 注：原文的代码阅读和拷贝起来不太方便，我已经摘录出来。 前言通过自定义View，实现的进阶版LyricView ，能够实现歌词滑动查看，当前播放位置高亮显示，滑动到指定位置并播放等等，大致和网易云音乐的歌词显示效果一样。 歌词文件的组成123456789101112131415[ti:一个人的北京][ar:好妹妹乐队][al:南北][by:][offset:0][00:00.10]一个人的北京 - 好妹妹乐队[00:00.20]词：秦昊[00:00.30]曲：秦昊[00:00.40][00:30.16]你有多久没有看到 满天的繁星[00:37.34]城市夜晚虚伪的光明 遮住你的眼睛......[04:48.87]离开了这里 在晴朗的天气[04:55.08][04:56.27]让我拥抱你 在晴朗的天气 歌词文件（*.lrc）都是以一个标准来进行制作的。123456[ti: 标题[ar: 歌手[al: 专辑[by: 制作[offset: 时间偏移量[mm:ss.ms] 歌词信息:由 开始时间（分：秒.毫秒）和 歌词内容 两部分组成 解析歌词文件首先获取*.lrc歌词文件的二进制流 InputStream，再又转换成字符流（注意：转化成字符流的时候需要选择编码，比如QQ音乐的歌词文件需要用”GBK”解码）。 准备两个类主要用于歌词解析结果的缓存：LyricInfo和 LineInfo（）： LyricInfo 歌词信息：包含标题、歌手、专辑等等1234567class LyricInfo &#123; List&lt;LineInfo&gt; song_lines; String song_artist;//歌手 String song_title;//标题 String song_album;//专辑 long song_offset;//偏移量&#125; LineInfo 歌词行信息：包含行开始时间和歌词行内容1234class LineInfo &#123; String content;//歌词内容 long start;//开始时间&#125; 解析歌词文件源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 初始化歌词信息 * @param inputStream 歌词文件的流信息 * */private void setupLyricResource(InputStream inputStream, String charsetName) &#123; if(inputStream != null) &#123; try &#123; LyricInfo lyricInfo = new LyricInfo(); lyricInfo.song_lines = new ArrayList&lt;&gt;(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charsetName); BufferedReader reader = new BufferedReader(inputStreamReader); String line = null; while((line = reader.readLine()) != null) &#123; analyzeLyric(lyricInfo, line); &#125; reader.close(); inputStream.close(); inputStreamReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; // 暂无歌词 &#125;&#125;/** * 逐行解析歌词内容 * */private void analyzeLyric(LyricInfo lyricInfo, String line) &#123; int index = line.lastIndexOf(&quot;]&quot;); if(line != null &amp;&amp; line.startsWith(&quot;[offset:&quot;)) &#123; // 时间偏移量 String string = line.substring(8, index).trim(); lyricInfo.song_offset = Long.parseLong(string); return; &#125; if(line != null &amp;&amp; line.startsWith(&quot;[ti:&quot;)) &#123; // title 标题 String string = line.substring(4, index).trim(); lyricInfo.song_title = string; return; &#125; if(line != null &amp;&amp; line.startsWith(&quot;[ar:&quot;)) &#123; // artist 作者 String string = line.substring(4, index).trim(); lyricInfo.song_artist = string; return; &#125; if(line != null &amp;&amp; line.startsWith(&quot;[al:&quot;)) &#123; // album 所属专辑 String string = line.substring(4, index).trim(); lyricInfo.song_album = string; return; &#125; if(line != null &amp;&amp; line.startsWith(&quot;[by:&quot;)) &#123; return; &#125; if(line != null &amp;&amp; index == 9 &amp;&amp; line.trim().length() &gt; 10) &#123; // 歌词内容 LineInfo lineInfo = new LineInfo(); lineInfo.content = line.substring(10, line.length()); lineInfo.start = measureStartTimeMillis(line.substring(0, 10)); lyricInfo.song_lines.add(lineInfo); &#125;&#125;/** * 从字符串中获得时间值 * */private long measureStartTimeMillis(String str) &#123; long minute = Long.parseLong(str.substring(1, 3)); long second = Long.parseLong(str.substring(4, 6)); long millisecond = Long.parseLong(str.substring(7, 9)); return millisecond + second * 1000 + minute * 60 * 1000;&#125; 验证解析效果完成歌词解析，接下来就是验证歌词解析的一个实际效果的时候了：12345678910111213141516File file = new File(Constant.lyricPath + &quot;一个人的北京 - 好妹妹乐队.lrc&quot;);if (file != null &amp;&amp; file.exists()) &#123; try &#123; setupLyricResource(new FileInputStream(file), &quot;GBK&quot;); StringBuffer stringBuffer = new StringBuffer(); if(lyricInfo != null &amp;&amp; lyricInfo.song_lines != null) &#123; int size = lyricInfo.song_lines.size(); for (int i = 0; i &lt; size; i ++) &#123; stringBuffer.append(lyricInfo.song_lines.get(i).content + &quot;\n&quot;); &#125; text.setText(stringBuffer.toString()); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 效果图： 就这样，一个简单的歌词显示功能也就实现了。 但是，如何才能够让自己写的音乐播放器在歌词显示模块能够显得高大上，并且能够像很多当前应用市场上流行的音乐播放器那样，实现当前播放高亮显示、歌词回弹效果、歌词淡入淡出效果以及滑动歌词快速播放等功能呢？ 请接着往下读….. 上面有提及到在早些前我有用 ScrollView 嵌套 TextView 的方式实现过自定义 LyricView，但是，由于体验效果和功能拓展上的不足，我并没有公开分享。既然通过 ScrollView 嵌套 TextView 的方式 不能满足 我们的设计需求，那是不是能够通过 自定义View 的方式实现 LyricView？既有如 TextView 那样的 LineHeigh(行高)、LineCount(总行数) 的概念，也有如 ScrollView 那样的 ScrollY(Y方向的偏移量) 的概念。那是必须的，说干就干。 LyricView实现解析*.lrc歌词文件，生成歌词集合列表，获得行总数 上面我已经讲过解析歌词了，而在 LyricView 中，我们需要做的是将逐行解析出来的歌词信息添加到 集合mLyricInfo 中，而 总行数mLineCount 也就等于 List集合 的大小 mLineCount = mLyricInfo.song_lines.size()。 计算歌词单行高度，获得歌词绘制区域总高度 写过 自定义View 的朋友应该都会知道，在 自定义View 中如果涉及文字的绘制，为了能够精准的绘制文字的位置，我们需要获取需要绘制的文字的矩形区域，通过画笔 Paint 的 getTextBounds(String text, int start, int end, Rect bounds)方法 则可以帮助我们轻松获得一个需要绘制文字的一个矩形。 当然，绘制文字矩形区域的大小还与文字的大小相关，我们还可以通过画笔 Paint 的 setTextSize(float textSize)方法 设置绘制文字大小，也就是常说的 TextSize。 在 LyricView 中，行高可不仅仅就只是文字矩形区域的高度，行高还包括两行之间的行间距，如下图所示。既然歌词总行数和歌词单行高度我们都已取得，那么获取歌词绘制区域的总高度也就so easy了：12345678/** * 计算行高度 * */private void measureLineHeight() &#123; Rect lineBound = new Rect(); mTextPaint.getTextBounds(mDefaultHint, 0, mDefaultHint.length(), lineBound); mLineHeight = lineBound.height() + mLineSpace;&#125; 计算行高度 定义 scrollY，并通过当前歌曲播放进度的时间戳计算 scrollY 既然 LyricView 能够实现滑动功能，那么引入 scrollY值 记录滑动偏移量，并控制视图绘制效果也就顺理成章。 需要明确一点，当偏移量 scrollY 的值为零的时候，歌词的首行将显示在整个 LyricView 的正中间 。 我们知道每一句歌词中都包含着开始时间，而我们也就可以通过当前歌曲播放进度匹配当前播放的行数 mCurrentPlayLine，并通过当前播放所在行，计算偏移量 scrollY 的值，控制歌词播放滚动和当前播放位置的高亮显示。12345678910for(int i = 0, size = mLineCount; i &lt; size; i ++) &#123; LineInfo lineInfo = mLyricInfo.song_lines.get(i); if(lineInfo != null &amp;&amp; lineInfo.start &gt; time) &#123; position = i; break; &#125; if(i == mLineCount - 1) &#123; position = mLineCount; &#125;&#125; 匹配当前播放行数 mCurrentPlayLine1234567/** * Input current showing line to measure the view&apos;s current scroll Y * @param line 当前指定行号 * */private float measureCurrentScrollY(int line) &#123; return (line - 1) * mLineHeight;&#125; 计算偏移量scrollY 理论基础已经实现，初步尝试绘图 onDraw：1234567891011121314151617181920212223242526272829for(int i = 0, size = mLineCount; i &lt; size; i ++) &#123; float x = getMeasuredWidth() * 0.5f; float y = getMeasuredHeight() * 0.5f + (i + 0.5f) * mLineHeight - 6 - mLineSpace * 0.5f - mScrollY; if(y + mLineHeight * 0.5f &lt; 0) &#123; continue; &#125; if(y - mLineHeight * 0.5f &gt; getMeasuredHeight()) &#123; break; &#125; if(i == mCurrentPlayLine - 1) &#123; mTextPaint.setColor(mHighLightColor); &#125; else &#123; if(mIndicatorShow &amp;&amp; i == mCurrentShowLine - 1) &#123; mTextPaint.setColor(mCurrentShowColor); &#125;else &#123; mTextPaint.setColor(mDefaultColor); &#125; &#125; if(y &gt; getMeasuredHeight() - mShaderWidth || y &lt; mShaderWidth) &#123; if(y &lt; mShaderWidth) &#123; mTextPaint.setAlpha(26 + (int) (23000.0f * y / mShaderWidth * 0.01f)); &#125; else &#123; mTextPaint.setAlpha(26 + (int) (23000.0f * (getMeasuredHeight() - y) / mShaderWidth * 0.01f)); &#125; &#125; else &#123; mTextPaint.setAlpha(255); &#125; canvas.drawText(mLyricInfo.song_lines.get(i).content, x, y, mTextPaint);&#125; Bingo ! 歌词确实能够在屏幕上绘制出来，细心的朋友也许会发现其中的几个特别的地方，分别是当前播放位置高亮显示和歌词淡入淡出效果实现的代码： 1234567891011121314//实现当前位置高亮显示if(i == mCurrentPlayLine - 1) &#123; mTextPaint.setColor(mHighLightColor);&#125;//歌词淡入淡出效果实现if(y &gt; getMeasuredHeight() - mShaderWidth || y &lt; mShaderWidth) &#123; if(y &lt; mShaderWidth) &#123; mTextPaint.setAlpha(26 + (int) (23000.0f * y / mShaderWidth * 0.01f)); &#125; else &#123; mTextPaint.setAlpha(26 + (int) (23000.0f * (getMeasuredHeight() - y) / mShaderWidth * 0.01f)); &#125;&#125; else &#123; mTextPaint.setAlpha(255);&#125; 但是，仅仅只是实现显示功能，并且超出范围的歌词内容还不能通过滑动来查看。哈哈~ 别着急啊，骚年，坐下来和我凉茶，听我细细道来。 重写 onTouchEvent，实现歌词滑动查看，并实现 overScroll 回弹效果 仅仅需要实现滑动视图的功能的话，说实话，非常简单，只需要记录 ACTION_DOWN 时的 y值，并比较 ACTION_MOVE 过程中的 y值 计算两者的差值，生成新的偏移量 scrollY，再刷新视图，就可以搞定 ! 要是就这么简简单单了事的话，怎么也不符合我个人对完美设计的要求。要是我们无限滑动的话，整个歌词内容区域就会滑动出我们的可视区域，也就是常说的 overScroll，如果不加以限制将会是一种非常差的用户体验。 当然，不同的开发对解决这个问题有不同的方法，有些播放器的歌词显示控件，当滑动事件出现 overScroll 时，将不再视图继续滑动。当然，也有当滑动事件出现 overScroll 时，视图依旧能够继续滑动，但与正常滑动时有所区别，这个时候的滑动会有一种 阻尼效果，也就是实际滑动距离和视图的滚动距离并不相等，而且随着 overScroll 的值越大，阻力越大，滑动越艰难，并在用户手指离开屏幕后回到 overScrol l的值为零的位置。当然，我本人更喜欢后者的用户体验，为了实现这个功能，那么就必须要在重写 onTouchEvent 的方法中”做点手脚”了。12345678910111213141516/** * 手势移动执行事件 * @param event * */private void actionMove(MotionEvent event) &#123; if(scrollable()) &#123; final VelocityTracker tracker = mVelocityTracker; tracker.computeCurrentVelocity(1000, maximumFlingVelocity); float scrollY = mLastScrollY + mDownY - event.getY(); // 102 -2 58 42 float value01 = scrollY - (mLineCount * mLineHeight * 0.5f); // 52 -52 8 -8 float value02 = ((Math.abs(value01) - (mLineCount * mLineHeight * 0.5f))); // 2 2 -42 -42 mScrollY = value02 &gt; 0 ? scrollY - (measureDampingDistance(value02) * value01 / Math.abs(value01)) : scrollY; // value01 / Math.abs(value01) 控制滑动方向 mVelocity = tracker.getYVelocity(); measureCurrentLine(); &#125;&#125; ACTION_MOVE1234567/** * 计算阻尼效果的大小 * */private final int mMaxDampingDistance = 360;private float measureDampingDistance(float value02) &#123; return value02 &gt; mMaxDampingDistance ? (mMaxDampingDistance * 0.6f + (value02 - mMaxDampingDistance) * 0.72f) : value02 * 0.6f;&#125; 阻尼大小计算 通过我一次一次对代码的细化，只要这么简单的两个方法，就完成了滑动时偏移量 scrollY 的计算，包括 overScroll 和 非overScroll，是的，只要这么两个方法。 到了这一步，歌词的显示、滑动查看都已经完成。但这还没完，我是不是还说过我的 LyricView 能够实现像网易云音乐歌词显示控件那样的指示器效果，哈哈哈 ~ 对于我这个完美主义者而言，这个功能必须实现。 歌词指示器效果图 实现歌词指示器效果，”屌丝”蜕变”高富帅” 其实，指示器效果实现起来也不是很难，其实指示器左侧的按钮完全可以用绘制 Bitmap 的方式其实现，但是，考虑到 LyricView 的灵活性，同时，我们程序猿不都是能够用代码绘制的决不在工程中添加图片的嘛 ！更何况就一个简单的播放按钮，随便画画，哈哈 ~ 至于，右侧的时间指示，则是通过当前偏移量 scrollY 的值计算得来的当前控件正中间位置显示歌词的开始时间。 12345678910111213141516171819/** * 绘制左侧的播放按钮 * @param canvas * */private void drawPlayer(Canvas canvas) &#123; mBtnBound = new Rect(mDefaultMargin, (int) (getMeasuredHeight() * 0.5f - mBtnWidth * 0.5f), mBtnWidth + mDefaultMargin, (int) (getMeasuredHeight() * 0.5f + mBtnWidth * 0.5f)); Path path = new Path(); float radio = mBtnBound.width() * 0.3f; float value = (float) Math.sqrt(Math.pow(radio, 2) - Math.pow(radio * 0.5f, 2)); path.moveTo(mBtnBound.centerX() - radio * 0.5f, mBtnBound.centerY() - value); path.lineTo(mBtnBound.centerX() - radio * 0.5f, mBtnBound.centerY() + value); path.lineTo(mBtnBound.centerX() + radio, mBtnBound.centerY()); path.lineTo(mBtnBound.centerX() - radio * 0.5f, mBtnBound.centerY() - value); mBtnPaint.setAlpha(128); canvas.drawPath(path, mBtnPaint); // 绘制播放按钮的三角形 canvas.drawCircle(mBtnBound.centerX(), mBtnBound.centerY(), mBtnBound. width() * 0.48f, mBtnPaint); // 绘制圆环&#125; 绘制指示器左侧播放按钮123456789101112131415161718/** * 绘制指示器 * @param canvas * */private void drawIndicator(Canvas canvas) &#123; mIndicatorPaint.setColor(mIndicatorColor); mIndicatorPaint.setAlpha(128); mIndicatorPaint.setStyle(Paint.Style.FILL); canvas.drawText(measureCurrentTime(), getMeasuredWidth() - mTimerBound.width(), (getMeasuredHeight() + mTimerBound.height() - 6) * 0.5f, mIndicatorPaint); Path path = new Path(); mIndicatorPaint.setStrokeWidth(2.0f); mIndicatorPaint.setStyle(Paint.Style.STROKE); mIndicatorPaint.setPathEffect(new DashPathEffect(new float[]&#123;20, 10&#125;, 0)); path.moveTo(mPlayable ? mBtnBound.right + 24 : 24 , getMeasuredHeight() * 0.5f); path.lineTo(getMeasuredWidth() - mTimerBound.width() - mTimerBound.width() - 36, getMeasuredHeight() * 0.5f); canvas.drawPath(path , mIndicatorPaint);&#125; 绘制指示器分割线和时间 既然设计播放按钮，当然播放按钮就要实现点击事件啊：1234567891011/** * 判断当前点击事件是否落在播放按钮触摸区域范围内 * @param event 触摸事件 * */private boolean clickPlayer(MotionEvent event) &#123; if(mBtnBound != null &amp;&amp; mDownX &gt; (mBtnBound.left - mDefaultMargin) &amp;&amp; mDownX &lt; (mBtnBound.right + mDefaultMargin) &amp;&amp; mDownY &gt; (mBtnBound.top - mDefaultMargin) &amp;&amp; mDownY &lt; (mBtnBound.bottom + mDefaultMargin)) &#123; float upX = event.getX(); float upY = event.getY(); return upX &gt; (mBtnBound.left - mDefaultMargin) &amp;&amp; upX &lt; (mBtnBound.right + mDefaultMargin) &amp;&amp; upY &gt; (mBtnBound.top - mDefaultMargin) &amp;&amp; upY &lt; (mBtnBound.bottom + mDefaultMargin); &#125; return false;&#125; 播放按钮点击位置判断12345678910if(mIndicatorShow &amp;&amp; clickPlayer(event)) &#123; if(mCurrentShowLine != mCurrentPlayLine) &#123; mIndicatorShow = false; if(mClickListener != null) &#123; mClickListener.onPlayerClicked( mLyricInfo.song_lines.get(mCurrentShowLine - 1).start, mLyricInfo.song_lines.get(mCurrentShowLine - 1).content); &#125; &#125;&#125; 到这一步，我们的自定义 LyricView 设计介绍也就告一段落咯 ！ 当然，功能远不止这些，还有 设置字体大小、设置行间距 以及 结合速度追踪器实现滑行效果 等等。所谓”授人以鱼不如授人以渔”，我想要和大家分享的是我的一个设计思路，大家可以根据需求设计不通的功能，因此在这里我也不做过多介绍，对小阿飞的 LyricView 感兴趣的朋友可以去我的gitHub下载研究：https://github.com/WuLiFei/LyricViewDemo 效果图overScroll效果展示 字体颜色设置效果展示 字体大小设置效果展示 行间距设置效果展示 指示器和播放按钮效果展示]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Fix集锦]]></title>
    <url>%2F2016%2F08%2F09%2F2016%2F2016-8-9-Android%20Fix%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[解决Android-Studio编译报错问题，找不到org-apache-http-legacy-md在使用Android Studio编译app时，系统提示：1Warning: Unable to find optional library: org.apache.http.legacy 注：Android Sdk 6.0这个其实是因为缺少一个json配置文件导致的问题。文件位置：1...AndroidSDK\platforms\android-23\optional 在此位置添加一个文件optional.json，内容如下：1234567[ &#123; &quot;name&quot;: &quot;org.apache.http.legacy&quot;, &quot;jar&quot;: &quot;org.apache.http.legacy.jar&quot;, &quot;manifest&quot;: false &#125;] 参考网址：Unable to find optional library - org.apache.http.legacy]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读：OKR管理方法]]></title>
    <url>%2F2016%2F07%2F06%2F2016%2F2016-7-6-OKR%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[员工评级系统——OKR(目标与关键结果)。 OKR是企业进行目标管理的一个简单有效的系统，能够将目标管理自上而下贯穿到基层。 OKR模型Objective: 针对如下3点，开发一个切实可行的模型，要求是可被计划和量化的。 Key Results： 按时完成陈述。 完成3个月的目标和关键结果。 管理同意并制定3个月的实验系统计划。 使用OKR系统的四个原因简单说OKR能让整个公司形成整体划一的行动。 训练思考能力（浮现重大目标） 精准交流（让每人都知道什么是重要的） 确立可测量的指示器（展示我们针对工作目标的进度） 聚焦成就（保持组织间的协同效率） OKR的工作原理自上而下，CEO设定目标，分解到部门，然后到团队，最后到个人.。 召开员工会议，从上到下，一对一双向沟通，协商要达成的目标。员工与管理者共同协商设置OKR目标。员工说，我想做X，雇主说我想你做Y，最后他们妥协敲定折中的Z目标。 公司目标 &lt;–&gt; 部门目标 &lt;–&gt; 小组目标 &lt;–&gt; 个人目标。 OKR循环流程每个季度的末尾： 和职员沟通，起草下一季度KR目标 下一个季度开头： 对上一季度每个职员的KR完成情况进行评分 完成当前季度 KR目标制定 在会议室展示上季度的KR评分，以及当前季度的KR目标。 跟进每一个职员当前季度 KR目标进度 OKR运作的时间线 对季度目标进行头脑风暴 在内部抓取和分享OKRs 沟通公司范畴的季度目标 起草个人OKRs 在公司和部门会议上展示个人OKRs 管理者跟进个人OKRs OKR的一些基本注意事项不要设定太多目标，最多不要超过五个。OKR不是绩效考核的武器!每个季度末对关键结果进行考核，完成60-70%就算好，如果100%完成，说明你的目标设定过于简单。 最多5个目标，每个目标4个KR。 60%以上的目标是由底向上提出的。 双方需要达成共识，而不是听取发号施令。 1页最好，最多不要超过2页。 不是一个 绩效/表现 评估武器。 60%~70% Good，40% Bad。 继续未完成的KR，如果他们很重要。 OKR给公司管理带来的提升 每人朝着同样的目标前进（聚焦成就，培养协同）。 保持组织协作。 所有的目标和关键结果支持组织目标。 大家开心工作。 设置可量化的OKR 以季度和年为单位 可量化的 设置个人、组织、公司 三个级别 OKR整个组织可见 每季度进行评分 OKR方法 The Objective 目标 野心勃勃的 有少量感觉不舒服 The Key Results 关键结果 目标清晰可达成 可以计量的 指向目标等级提升 OKR在企业中的应用 个人OKRs定义了个人要做什么 团队OKRs定义了针对团队OKRs的优先级，不是简单的个人OKRs的集合。 公司OKRs是一副蓝图，服务于公司焦点。 OKRs打分每个季度末进行打分 打分应当在数分钟内完成，别花太多时间 0.6~0.7分是目标。 打分单成绩没有工作过程重要。 公司氛围的打分加强了许诺意义。 再评价低分：有哪些有价值？做什么改变的话有达成目标的可能？ OKRs 全公司透明OKR的成功在于开放，全公司都应该做到互相透明。 对上季度OKRs进行评级 对OKR owner解释等级评分，解释下一季度的调整。 设定当前季度的OKRs 提交OKR报告管理层应当全力推行OKR，以下是一位产品经理羞辱员工的信，因为他没有提交OKR报告。 OKR是让员工和企业围绕共同目标前进的简明系统。一位员工有很多目标，需要定义可量化的方法来达成目标。最后就是所有人都能看到其他人的OKR，这样确保全公司的管理做到真正的透明化，达成行动策略上的一致性。 参考网址]]></content>
  </entry>
  <entry>
    <title><![CDATA[“深淘滩，低作堰”-华为公司的战略创新和机制创新]]></title>
    <url>%2F2016%2F05%2F10%2F2016%2F2016-5-10-%E2%80%9C%E6%B7%B1%E6%B7%98%E6%BB%A9%EF%BC%8C%E4%BD%8E%E4%BD%9C%E5%A0%B0%E2%80%9D-%E5%8D%8E%E4%B8%BA%E5%85%AC%E5%8F%B8%E7%9A%84%E6%88%98%E7%95%A5%E5%88%9B%E6%96%B0%E5%92%8C%E6%9C%BA%E5%88%B6%E5%88%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[陕西省企业管理讲座笔记：华为公司的战略创新和机制创新 #未来的市场竞争是知识产权之争 ##没有核心IPR的国家，拥有不会成为工业强国 将来的市场竞争就是IPR（知识产权）之争，就是未来的企业之争。所以将来没有核心IPR的国家，永远不会成为工业强国。我们国家提出要自主创新。首先要用法律的手段保护知识产权，自己的，别人的知识产权应一视同仁的保护。 实际上保护知识产权是我们自己的需要，而不是别人用来打压我们的手段。如果认识到这一点，几十年，上百年后我们国家的科技就有希望了。但是科技不是一个急功近利的事情。一个理论的突破，构成社会价值需要二三十年。 #管理创新的七反对原则 ##不断改良，不断优化，无穷逼近合理 管理改革是继续坚持从实用的目的出发，达到适用目的的原则，在管理改进中，要持续坚持“七反对”的原则。“坚决反对完美主义，坚决反对繁琐哲学，坚决反对盲目的创新，坚决反对没有全局效益提升的局部优化，坚决反对没有全局观的干部主导变革，坚决反对没有业务实践经验的人参加变革，坚决反对么有充分论证的流程进入实用”。 “小改进，大奖励”是我们长期坚持不懈的改良方针。应在小改进的基础上，不断归纳，综合分析，研究其与公司总体目标流程的符合，与周边流程的和谐。要简化、优化、再同化。要以贡献率的提高不断地改进。 #关于公司战略的基本观点 ##什么是战略? 战略是为实现企业的长远目标所做的方向选择、重大取舍和对战术的创造性运用。以及对资源分配优先次序的锲而不舍的承诺。 ##战略方向选择的例子 开拓市场还是进入新领域？A–&gt;BA–&gt;D| – | 现有市场 | 新市场 || ————- |:————-:| —–:||现有产品 | A| B|| 新产品 | C | D | #客户需求和技术创新双轮驱动 ##以客户需求为中心做产品，以技术为中心做未来架构性的平台 什么是解决方案？解决方案不是以技术为中心，是以需求为中心，这是前端的；后端的以技术为中心，是储备性的。我们要加大以技术为中心的战略性投入，以领先时代，我们以客户为中心讲多了以后，可能会从一个极端走向另一个极端，会忽略以技术为中心的超前战略。将来我们以技术为中心和以客户为中心两者是拧麻花一样的，一个以客户需求为中心，来做产品；一个以技术为中心，来做未来架构性平台。 ##满足客户需求的技术创新和积极响应世界科学进步的不懈探索双轮驱动公司进步 现在我们是两个轮子在创新，一个是科学家的创新，他们关注技术，愿意怎么想就怎么想。但是他们不能左右应用。技术是否要投入使用，什么时候投入使用，我们要靠另一个轮子Marketing（营销），Marketing不断地在听客户的声音，包括今天的需求，明天的需求，未来战略的需求。才能确定我们掌握的技术该怎么用，以及投入市场的准确时间。 #增长的4个悖论 你业务单元的绩效越好，越有可能运营在远低于该业务的全部潜能的水平上。 注：此处黄老师拿华为业务天花板做了举例。 你的核心业务越强，你就有越多的机会迁移到临近的盈利领域和失去焦点。 越是受益于向相邻领域扩张的管理团队，在产业动荡中越显得脆弱。 #鲜花插在牛粪上，在继承的基础上创新 ##无边界的技术创新有可能会误导公司战略 我们对研究和创新的约束是有边界的，只能聚焦在主航道上。产品创新一定要围绕商业需要，对于产品的创新是有约束的，不准胡乱创新。贝尔实验室为什么最后垮了，电子显微镜是贝尔实验室发明的，但他的本职是做通讯的。它未来满足可虚假的个人愿望就发明了这个电子显微镜。发明后成果丢到外面划不来，就成立了电子显微镜的组织作为商业面的承载。所以无边界的技术创新有可能会误导公司战略。我们说做产品的创新不能无边界，研究与创新做的宽一点但也不能无边界。我们要成就的是华为的梦想，不是人类的梦想。所以我们的创新应该是有边界的，不是无边界的。 #把能力中心建到战略资源聚集地区 我们要把战略的能力中心，放到战略资源的聚集地去。大公司要敢于用密集投资，缩短追赶时间和延长机会窗开启的时间。 我们的产品要讲究质量，不仅仅是针对硬件，也包括软件。世界上软件做得好的公司，除了一家在德国外，其他全在美国。所以应该在西雅图建立一个软件研究所。把物理类和逻辑类研究分开，否则我们的软件就不可能做到最好。美国这个国家的创新机制、创新精神、创新动力很强，我们不要固步自封，一定要把战略能力中心放到战略资源聚集地去。 #深淘滩，低作堰 ##华为公司的商业模式 华为在通信领域不做资本性的交易。将长期保留通信网络的开发、销售和服务的体系，这个体系将来受社会进步、技术进步的影响。产品会变得越来越不值钱，像鸡肋一样。许多公司会选择逐步放弃，而人们还是需要这些东西的。我司将坚持不动地持续开发，维护这些鸡肋产品。 在这些低利产品中，要生存下来。唯有实现高质量、优质服务，内部运作低成本和优先满足客户需求。就像薇甘菊一样，在低生存条件下蔓延生长。以后切一块这个优质的管理平台的一部分。独立出去再种上百上千势头的产品，必将产生最快的增值。 注：此处黄老师提到，华为在此点上，要做免维护的产品为目标。 ##决不放弃低端市场 要成为行业的薇甘菊，就必须具备实力，没有实力是做不了霸主的。实力就是高质量，低成本，尤其是末端产品更要强化这种观念。我们只有在末端产品上具备了高质量、低成本才不怕恶劣市场的挑战，才不怕被对手打倒。才能在激烈市场中生存下来。薇甘菊理论要在我们低端产品上生根。 低端产品要做到标准化，简单化。生命周期内免维修。我们不走低价格、低质量的路，那样会摧毁我们战略进攻的力量。在技术和服务模式上，要做到别人无法与我们竞争，就是大规模流水化。客户想要增加功能，就买高端产品去，这就是薇甘菊理论。而且我们现在也具备这个条件。 #商业模式颠覆性创新的特征 在相反的方向上寻求突破。在对立的事物中寻求统一。收费==免费复杂==简单粗放==精准。。。标准化==个性化。。。 #华为的核心价值观以客户为中心，以奋斗者为本，长期艰苦奋斗，坚持自我批判。 华为公司的人力资源管理框架 #战略性地管理人力资源流动 ##高层领导的选拔应遵循什么原则？ ##猛将必发于卒武，宰相必取于州郡。 我们要坚持从成功的实践中选拔干部，坚持“猛将必发于卒伍，宰相必取于州郡”的理念，引导优秀儿女不畏艰险，不谋私利，走上最需要的地方。 ##机关干部必须到海外去锻炼所有机关干部，都要置换，从上到下，都要查自己无实践经验，机关干部必须要有具有实践经验的人来做，必须能够理解前方是怎么运作的。 ##怎么形成一种有利于优秀人才成长的机制？ 干部要能上能下，如果我们，不能形成一种有利于优秀人才成长的机制。我们必将盛极而必衰。 干部任用的三最佳原则，干部要在最佳的角色上，在最佳的时间段上，做出最佳的贡献，和得到合理的回报。 我的微信公众号：一一小知（yiyixiaozhi）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[读《重新定义公司》]]></title>
    <url>%2F2016%2F05%2F04%2F2016%2F2016-5-4-%E8%AF%BB%E3%80%8A%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%85%AC%E5%8F%B8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本书作者是谷歌执行董事长埃里克·施密特和前高级副总裁乔纳森·罗森伯格，他们亲自分享十余年来帮助谷歌成长的管理启示。你会在其中找到你正在面临的，或者即将面临的问题的解决方向。 当乔纳森和埃里克刚加入Google的时候，还自以为对公司的成功运营之道了如指掌。但他们很快就发现，自己对企业管理的见解大错特错。未来组织的责任不再是管理员工，甚至也不是激励员工，而是给员工赋能。赋能意味着什么呢？就是给员工提供更高效创造的环境和工具。员工在这个平台能够把自己的能力发挥到最大，赋能才是未来组织真正的责任。 如果我们把传统知识工作者跟谷歌十几年来招聘的工程师等人才放在一起对比，就会发现谷歌有一个截然不同的员工群体。在谷歌，个人和小团队可以拥有巨大影响力，他们可以勾画出新的想法，反复试验，总结经验，因此在全球市场上抢占先机。 谷歌将这些拥有最大影响力的人称为“创意精英”（Smart Creatives）。这些人自动自发，并不拘泥于特定任务。他们有战略的能力，不怕冒险也不怕混乱。即使在冒险中失败，也善于面对逆境。如果出现不同意见，他们能够用数据说话、善于做分析，并且心态开放、善于沟通。传统组织中，人们面对混乱常常互相推诿从而引发大量矛盾，导致组织效率低下。真正的创意精英会自发的把所有精力集中在如何更好地解决问题，不存在“这是你应该做的事”或者“这事跟我没关系”。 事实上，同时具备这些优点的人凤毛麟角，但是所有创意精英都必须具备一些基本特质：商业头脑、专业知识、创造力以及实践经验。而对于这些人，他们最主要的驱动力是创造带来的成就感和社会价值，自我激励是他们的特征。他们不需要激励而需要赋能，也就是提供给他们能更高效创造的环境和工具！谷歌认为，员工应该都成为创意精英，才能够使得这个组织产生赋能的效应。谷歌掌门人埃里克在这本书里通过了文化、战略、人才、决策、沟通和创新六个角度向大家展示了谷歌是如何运营的。 文化：相信自己的口号 谷歌有很多有意思的文化,比如允许带狗上班。虽然谷歌有着轻松愉快的工作环境，但这些并不是谷歌文化中最核心的部分。真正文化的核心是所有的人都要能够相信自己的口号。 谷歌有句口号叫“不作恶”。一次会议上，大家讨论到对广告管理模式作出一项改变可能带来的好处。虽然这一改变有可能为公司带来丰厚的利润，但一位工程负责人却拍案反驳：“这是在作恶，这事我们不能做！”最终，做出改变的提案被否决。“不作恶”这句口号的确真诚表达了谷歌的企业价值观，同时也赋予了每位员工都有权利判断公司决策的权利。 为了更好的塑造这种文化，谷歌有很多方法： 1、拥挤出成绩——如果你伸手就能碰到身边的人，这就是合适的维度，这样你们之间的交流和创意的互动就是畅通无阻的。 2、一起吃住，一起工作——不同职能团队的人应该整合在一起办公。 3、别听父母的：杂乱是种美德——混乱往往是自我表达和创新的衍生品，把东西收拾得井井有条会导致你的创造力下降。 4、别听“河马”的话——职场中的“河马”指的是高层、高管。他们常常抱着“我说了算”的施压态度来达到自己的目的。要营造任人唯贤的环境，必须强调“质疑”的文化。 5、“7的法则”——即一个管理者每天接收到的报告不要超过七封。这条法则能让企业的组织结构趋于扁平，减少管理层的监督并赋予员工更多的自由。 6、切莫自扫门前雪——谷歌坚持按职能划分部门，每个部门直接向首席执行官汇报。因为以业务或产品线为基础的组织结构，会对人员信息的自由流动形成扼制。 7、驱逐恶棍，保护明星——作为管理者，一旦在团队发现“害群之马”，最好的方法是立刻驱逐。一家企业的品格是所有成员品格的总和，如果破坏公司文化、人品不端的人数比例达到一个数值时，大家就会认为自己必须迎合恶棍的做法才有出路。 8、营造说“好”的文化——总说“不”，会扼制创意精英。 9、快乐工作——快乐文化与创意文化有一个共同点：快乐无处不在。真正的快乐是伪装不来的，信赖你的员工，尽量放宽限制，不要因惧怕出纰漏而杞人忧天。员工越快乐就越能干。 10、上班穿什么？——埃里克回答说：“别光着身子就行。”谷歌会让大家参照当天的环境和周围的人来自行决定服装。 11、跟我来——在迎战敌军的时候，以色列坦克指挥官并不会大喊“给我冲”，而是说“跟我来”。领导者们会从自身做起，践行平等的理念：我们同舟共济，职责共担。 因此，谷歌文化的核心是——创意精英文化。这里给创意精英提供了土壤和平台，当所有人都想成为创意精英并且以创意精英的标准来要求自己时，公司文化就淌进了人们的血液。 战略：你的计划是错的! 绝大多数人在开创一份冒险事业之前都会做商业计划，然而事事都处在瞬息万变之中。任何完备的MBA式的商业计划都会在某些至关重要的方面存在漏洞。计划要以战略为根基。一份好的计划有三个重要原则： 1、以独特的技术洞见为基础来打造优质的产品，而非市场调查。亨利•福特当年说：“如果我去问消费者想要什么样的交通工具，他们一定会说想要更快的马。”因为人们当时只知道骑马，根本不可能想到汽车。发明汽车就是“洞见”。 2、开放为王（不要只盯着收益，要以发展为先）。谷歌的很多产品都是免费的，比如搜索和谷歌地球。他们发现平台越开放，越容易实现快速扩张，也能够找到更多的盈利点。 3、了解竞争对手的情况，但不要被牵着鼻子走。许多企业领导者花费大量时间来观察和模仿竞争对手，殊不知这时往往会杀出一个不在乎市场占有率的竞争者，用全新的平台颠覆整个游戏。 人才：招聘是你最重要的工作 1、加大“光圈”甄别人才。一般招聘主管的光圈很小，只会考虑已经拥有一定头衔并且当下能把事做好的人。然而把光圈调大，物色一些经验不足但有潜力的人（学习型人才），通常能为企业带来出人意料的创举。 2、把时间花在招聘上永远都不会浪费。即便是高层级的人，也依然要经过严格的面试才能够进入谷歌，所以招人对于公司管理者来讲是最重要的一件事。 3、要持续雇佣顶尖人才，就要摒弃层级制，而应该通过同事评估、招聘委员会定夺。传统公司里决定大权掌握在用人部门的经理手中，而如果该部门经理离职，那么当初被这个经理招进来的成员可能无法很好地跟其他成员协作。如果采用招聘委员会的模式，每个成员通过打分来筛选新的合作伙伴，根据分数情况来决定是否需要下一轮面试，这个人就更有可能接近整个团队的要求。 4、全员出动招募人才——要把招募人才纳入每位员工的职责，并进行评估。建立一种成功的招聘文化，让企业规模更容易翻倍。因为顶尖的人才就像羊群，人们之间会互相交往，优质人才会为你带来更优质的人才。 决策：共识的真正含义 正确的决策方法会让创意精英们意识到自己有改变世界的潜力，但错误的决策方法会扼杀大家的士气。制定决策的方式、时机和实施决策的具体方法都很重要。谷歌认为，少了数据就没法做决策。同时，领导人要少做决策，你需要关心但不要插手。你的任务就是分析数据、鼓励讨论、引导大家达成共识。 沟通：塑造善于沟通的氛围，当最牛的路由器 在沟通的层面，谷歌有很高的要求。最有能力的管理者善于分享信息，在沟通的过程中保持开放。领导者的目标，就是要时刻促进信息在整个企业中的流动。 谷歌放心将各种关乎企业命脉的信息与员工共享，而员工也不负这份信赖。 很多重要的事需要领导者苦口婆心的重复进行沟通以达到效果，比如企业的核心理念等，重要的事因为被重复而会更加深入人心。 创新：缔造最原始的混沌 曾经有个工程师告诉创始人拉里·佩奇，有一个提议可以为谷歌带来几十亿美元的收入，佩奇听了说：“这个想法不够大，把想法放大十倍试试。”这个十几亿美元的构想因为不够大被否决掉了。那么什么是他们认为比较大的想法呢？ 有几个原则： 第一，这个想法必须涉及一个能够影响数亿人甚至几十亿人的巨大挑战或机遇。 第二，这个想法必须提供一种与市场上现存的解决方案截然不同的方法。是另辟蹊径，而不是在已有的做事方法上改进。 第三，将突破性解决方案变为现实的科技至少必须具备可行性，且在不久的将来可以实现。 以上就是谷歌要去做的创新的方向。 同时，谷歌提倡20%时间制，允许工程师拿出20%的时间来研究自己喜欢的项目。语音服务、谷歌新闻、谷歌地图上的交通信息等，都是20%时间的创新产物。 当一个人内心有着改变世界的动力时，是不需要他人要求的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[读：软件模块的3项职责]]></title>
    <url>%2F2016%2F04%2F25%2F2016%2F2016-4-25-%E8%AF%BB%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9D%97%E7%9A%843%E9%A1%B9%E8%81%8C%E8%B4%A3%2F</url>
    <content type="text"><![CDATA[“大千世界中，唯一缺乏的就是人类的注意力。”——凯文•凯利要使软件易于阅读和修改，所需要的不仅仅是一些原则和模式。还需要你的注意力，需要纪律约束，需要创造美的激情。 每一个软件模块都有三项职责。 功能职责（是否完成了功能？）它运行起来所完成的功能，这也是该模块得以存在的原因。 变化职责（是否能够应对变化？）它要应对变化，几乎所有的模块在它们的晟敏周期中都要变化，开发者有责任保证这种改变应该尽可能简单。一个难以改变的模块是拙劣的，即时能够工作，也需要对它进行修正。 交流职责（换一个人，是否可读？）要和阅读它的人进行沟通。对该模块不熟悉的开发人员应该能够比较容易地阅读并理解它。一个无法进行沟通的模块也是拙劣的，同样需要对它进行修正。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Sublime Text + Graphviz + Dot 来绘制有向图]]></title>
    <url>%2F2016%2F04%2F25%2F2016%2F2016-4-25-SublimeText%2BGraphviz%2BDot%3D%E6%9C%89%E5%90%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Graphviz介绍介绍一个高效而简洁的绘图工具graphviz。graphviz是贝尔实验室开发的一个开源的工具包，它使用一个特定的DSL(领域特定语言): dot作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。graphviz提供丰富的导出格式，如常用的图片格式，SVG，PDF格式等。 graphviz中包含了众多的布局器： dot 默认布局方式，主要用于有向图 neato 基于spring-model(又称force-based)算法 twopi 径向布局 circo 圆环布局 fdp 用于无向图 本文主要介绍dot有向图。 首先，在dot脚本中定义图的顶点和边，顶点和边都具有各自的属性，比如形状，颜色，填充模式，字体，样式等。然后使用合适的布局算法进行布局。布局算法除了绘制各个顶点和边之外，需要尽可能的将顶点均匀的分布在画布上，并且尽可能的减少边的交叉(如果交叉过多，就很难看清楚顶点之间的关系了)。所以使用graphviz的一般流程为： 定义一个图，并向图中添加需要的顶点和边 为顶点和边添加样式 使用布局引擎进行绘制 在我的机器上，使用Sublime Text 编辑dot脚本，然后将F7/Cmd-B映射为调用dot引擎去绘制当前脚本，并打开一个新的窗口来显示运行结果： Sublime Text 3 集成Graphviz方法如下：第一步：下载https://github.com/munro/SublimeGraphvizPreview/archive/master.zip第二步：打开Preferences -&gt; Packages Settings-&gt; Packages Control -&gt; Settings User，来确认一下installed_packages没有GraphVizPreview。并且增加”remove_orphaned”: false防止Sublime Text 把手动安装的插件包给删除了。12345678910111213&#123; "bootstrapped": true, "in_process_packages": [ ], "installed_packages": [ "EncodingHelper", "Package Control", "Theme - Spacegray" ], "remove_orphaned": false&#125; 第三步：打开Preferences -&gt; Browse Packages…进入到Sublime Text的插件包下Packagas。第四步：解压zip文件到Packagas下，并且更改文件夹SublimeGraphvizPreview-master为GraphVizPreview。第五步：重启Sublime Text。 注：快捷键为Win+Shift+G，调用Graphviz 调用dot引擎去绘制当前脚本。 使用graphviz绘制流程图 注：引用image图片的时候，需要使用命令，使用 dot 命令编译，如 dot hello.dot -T png -o hello.png 完整的命令为:1＜cmd＞ ＜inputfile＞ -T ＜format＞ -o ＜outputfile＞ 示例如下：1D:\\&gt;dot -Tjpg tes.dot -o test.jpg &lt;cmd&gt; 介绍 dot 渲染的图具有明确方向性。 neato 渲染的图缺乏方向性。 twopi 渲染的图采用放射性布局。 circo 渲染的图采用环型布局。 fdp 渲染的图缺乏方向性。 sfdp 渲染大型的图，图片缺乏方向性。 基础知识graphviz包含3中元素，图，顶点和边。每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等。 第一个graphviz图12345678910digraph abc&#123; a; b; c; d; a -&gt; b; b -&gt; d; c -&gt; d;&#125; 定义顶点和边的样式123456789101112digraph abc&#123; node [shape=&quot;record&quot;]; edge [style=&quot;dashed&quot;]; a; b; c; d; a -&gt; b; b -&gt; d; c -&gt; d;&#125; 进一步修改顶点和边样式将顶点a的颜色改为淡绿色，并将c到d的边改为红色。12345678910111213digraph abc&#123; node [shape=&quot;record&quot;]; edge [style=&quot;dashed&quot;]; a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;]; b; c; d; a -&gt; b; b -&gt; d; c -&gt; d [color=&quot;red&quot;];&#125; 子图的绘制12345678910111213141516171819digraph abc&#123; node [shape=&quot;record&quot;]; edge [style=&quot;dashed&quot;]; a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;]; b; subgraph cluster_cd&#123; label=&quot;c and d&quot;; bgcolor=&quot;blue&quot;; c; d; &#125; a -&gt; b; b -&gt; d; c -&gt; d [color=&quot;red&quot;];&#125; 注:子图的名称必须以cluster开头，否则graphviz无法设别。 数据结构的可视化一个hash表的数据结构hash表内容123456789101112131415161718192021struct st_hash_type &#123; int (*compare) (); int (*hash) ();&#125;; struct st_table_entry &#123; unsigned int hash; char *key; char *record; st_table_entry *next;&#125;; struct st_table &#123; struct st_hash_type *type; int num_bins;/* slot count */ int num_entries;/* total number of entries */ struct st_table_entry **bins;/* slot */&#125;; 脚本如下：1234567891011121314151617digraph st2&#123; fontname = &quot;Verdana&quot;; fontsize = 10; rankdir=TB; node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;]; edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;]; st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;]; st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;]; st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;]; st_table:bins -&gt; st_table_entry:head; st_table:type -&gt; st_hash_type:head; st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];&#125; 注：在顶点的形状为record的时候，label属性的语法比较奇怪，但是使用起来非常灵活。比如，用竖线”|”隔开的串会在绘制出来的节点中展现为一条分隔符。用&lt;&gt;括起来的串称为锚点，当一个节点具有多个锚点的时候，这个特性会非常有用，比如节点st_table的type属性指向st_hash_type，第4个属性指向st_table_entry等，都是通过锚点来实现的。 使用默认的dot布局后，绿色的这条边覆盖了数据结构st_table_entry，并不美观，因此可以使用别的布局方式来重新布局，如使用circo算法可以得到更加合理的布局结果。1D:\\&gt;circo -Tjpg tes.dot -o test.jpg hash表的实例123456789101112131415161718192021222324252627282930313233343536373839404142digraph st&#123; fontname = &quot;Verdana&quot;; fontsize = 10; rankdir = LR; rotate = 90; node [ shape=&quot;record&quot;, width=.1, height=.1]; node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;]; edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;]; node [shape=&quot;plaintext&quot;]; st_table [label=&lt; &lt;table border=&quot;0&quot; cellborder=&quot;1&quot; cellspacing=&quot;0&quot; align=&quot;left&quot;&gt; &lt;tr&gt; &lt;td&gt;st_table&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;num_bins=5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;num_entries=3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td port=&quot;bins&quot;&gt;bins&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &gt;]; node [shape=&quot;record&quot;]; num_bins [label=&quot; &lt;b1&gt; | &lt;b2&gt; | &lt;b3&gt; | &lt;b4&gt; | &lt;b5&gt; &quot;, height=2]; node[ width=2 ]; entry_1 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;next&#125;&quot;]; entry_2 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;null&#125;&quot;]; entry_3 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;null&#125;&quot;]; st_table:bins -&gt; num_bins:b1; num_bins:b1 -&gt; entry_1:e; entry_1:next -&gt; entry_2:e; num_bins:b3 -&gt; entry_3:e;&#125; 注：LR指定了左右排序方式。可以看到，节点的label属性支持类似于HTML语言中的TABLE形式的定义，通过行列的数目来定义节点的形状，从而使得节点的组成更加灵活。 软件模块组成图123456789101112131415161718192021222324252627282930313233343536digraph idp_modules&#123; rankdir = TB; fontname = &quot;Microsoft YaHei&quot;; fontsize = 12; node [ fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;record&quot; ]; edge [ fontname = &quot;Microsoft YaHei&quot;, fontsize = 12 ]; subgraph cluster_sl&#123; label=&quot;IDP支持层&quot;; bgcolor=&quot;mintcream&quot;; node [shape=&quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;]; network_mgr [label=&quot;网络管理器&quot;]; log_mgr [label=&quot;日志管理器&quot;]; module_mgr [label=&quot;模块管理器&quot;]; conf_mgr [label=&quot;配置管理器&quot;]; db_mgr [label=&quot;数据库管理器&quot;]; &#125;; subgraph cluster_md&#123; label=&quot;可插拔模块集&quot;; bgcolor=&quot;lightcyan&quot;; node [color=&quot;chartreuse2&quot;, style=&quot;filled&quot;]; mod_dev [label=&quot;开发支持模块&quot;]; mod_dm [label=&quot;数据建模模块&quot;]; mod_dp [label=&quot;部署发布模块&quot;]; &#125;; mod_dp -&gt; mod_dev [label=&quot;依赖...&quot;]; mod_dp -&gt; mod_dm [label=&quot;依赖...&quot;]; mod_dp -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;]; mod_dev -&gt; mod_dm [label=&quot;依赖...&quot;]; mod_dev -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;]; mod_dm -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];&#125; 状态图1234567891011121314151617181920digraph automata_0 &#123; size = &quot;8.5, 11&quot;; fontname = &quot;Microsoft YaHei&quot;; fontsize = 10; node [shape = circle, fontname = &quot;Microsoft YaHei&quot;, fontsize = 10]; edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 10]; 0 [ style = filled, color=lightgrey ]; 2 [ shape = doublecircle ]; 0 -&gt; 2 [ label = &quot;a &quot; ]; 0 -&gt; 1 [ label = &quot;other &quot; ]; 1 -&gt; 2 [ label = &quot;a &quot; ]; 1 -&gt; 1 [ label = &quot;other &quot; ]; 2 -&gt; 2 [ label = &quot;a &quot; ]; 2 -&gt; 1 [ label = &quot;other &quot; ]; &quot;Machine: a&quot; [ shape = plaintext ];&#125; 12345678910111213141516171819202122232425digraph finite_state_machine &#123; rankdir = LR; size = &quot;8,5&quot; node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8; node [shape = circle]; LR_0 -&gt; LR_2 [ label = &quot;SS(B)&quot; ]; LR_0 -&gt; LR_1 [ label = &quot;SS(S)&quot; ]; LR_1 -&gt; LR_3 [ label = &quot;S($end)&quot; ]; LR_2 -&gt; LR_6 [ label = &quot;SS(b)&quot; ]; LR_2 -&gt; LR_5 [ label = &quot;SS(a)&quot; ]; LR_2 -&gt; LR_4 [ label = &quot;S(A)&quot; ]; LR_5 -&gt; LR_7 [ label = &quot;S(b)&quot; ]; LR_5 -&gt; LR_5 [ label = &quot;S(a)&quot; ]; LR_6 -&gt; LR_6 [ label = &quot;S(b)&quot; ]; LR_6 -&gt; LR_5 [ label = &quot;S(a)&quot; ]; LR_7 -&gt; LR_8 [ label = &quot;S(b)&quot; ]; LR_7 -&gt; LR_5 [ label = &quot;S(a)&quot; ]; LR_8 -&gt; LR_6 [ label = &quot;S(b)&quot; ]; LR_8 -&gt; LR_5 [ label = &quot;S(a)&quot; ];&#125; 模块的生命周期图123456789101112131415161718192021222324252627digraph module_lc&#123; rankdir=TB; fontname = &quot;Microsoft YaHei&quot;; fontsize = 12; node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;]; edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ]; installed [label=&quot;已安装状态&quot;]; resolved [label=&quot;已就绪状态&quot;]; uninstalled [label=&quot;已卸载状态&quot;]; starting [label=&quot;正在启动&quot;]; active [label=&quot;已激活(运行)状态&quot;]; stopping [label=&quot;正在停止&quot;]; start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;]; start -&gt; installed [label=&quot;安装&quot;]; installed -&gt; uninstalled [label=&quot;卸载&quot;]; installed -&gt; resolved [label=&quot;准备&quot;]; installed -&gt; installed [label=&quot;更新&quot;]; resolved -&gt; installed [label=&quot;更新&quot;]; resolved -&gt; uninstalled [label=&quot;卸载&quot;]; resolved -&gt; starting [label=&quot;启动&quot;]; starting -&gt; active [label=&quot;&quot;]; active -&gt; stopping [label=&quot;停止&quot;]; stopping -&gt; resolved [label=&quot;&quot;];&#125; 简单的抽象语法树12345678910111213141516digraph ast&#123; fontname = &quot;Microsoft YaHei&quot;; fontsize = 10; node [shape = circle, fontname = &quot;Microsoft YaHei&quot;, fontsize = 10]; edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 10]; node [shape=&quot;plaintext&quot;]; mul [label=&quot;mul(*)&quot;]; add [label=&quot;add(+)&quot;]; add -&gt; 3 add -&gt; 4; mul -&gt; add; mul -&gt; 5;&#125; 简单的UML类图12345678910111213141516171819202122digraph G&#123; fontname = &quot;Courier New&quot; fontsize = 10 node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ]; edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ]; Animal [ label = &quot;&#123;Animal |+ name : String\\l+ age : int\\l|+ die() : void\\l&#125;&quot; ]; subgraph clusterAnimalImpl&#123; bgcolor=&quot;yellow&quot; Dog [ label = &quot;&#123;Dog||+ bark() : void\\l&#125;&quot; ]; Cat [ label = &quot;&#123;Cat||+ meow() : void\\l&#125;&quot; ]; &#125;; edge [ arrowhead = &quot;empty&quot; ]; Dog-&gt;Animal; Cat-&gt;Animal; Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];&#125; 时序图123456789101112131415161718192021222324252627282930313233digraph G &#123; rankdir=&quot;LR&quot;; node[shape=&quot;point&quot;, width=0, height=0]; edge[arrowhead=&quot;none&quot;, style=&quot;dashed&quot;] &#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; LC[shape=&quot;plaintext&quot;]; LC -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05; &#125; &#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; Agency[shape=&quot;plaintext&quot;]; Agency -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15; &#125; &#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; Agent[shape=&quot;plaintext&quot;]; Agent -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25; &#125; step00 -&gt; step10 [label=&quot;sends email new custumer&quot;, arrowhead=&quot;normal&quot;]; step11 -&gt; step01 [label=&quot;declines&quot;, arrowhead=&quot;normal&quot;]; step12 -&gt; step02 [label=&quot;accepts&quot;, arrowhead=&quot;normal&quot;]; step13 -&gt; step23 [label=&quot;forward to&quot;, arrowhead=&quot;normal&quot;]; step24 -&gt; step14; step14 -&gt; step04 [arrowhead=&quot;normal&quot;];&#125; rankdir=”LR”表示，布局从左L到右R。可以看到，在代码中有{}括起来的部分。123456&#123; rank=&quot;same&quot;; edge[style=&quot;solided&quot;]; Agency[shape=&quot;plaintext&quot;]; Agency -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15;&#125; 每一个rank=”same”的block中的所有节点都会在同一条线上。我们设置了所有的线为虚线，但是在该block中，将线改为solided。 如果你追求高效的开发速度，并希望快速的将自己的想法画出来，那么graphviz是一个很不错的选择。graphviz的强项在于自动布局，当图中的顶点和边的数目变得很多的时候，才能很好的体会这一特性的好处。 最后，提供Graphviz下载地址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何搭建一个属于自己的直播平台]]></title>
    <url>%2F2016%2F02%2F02%2F2016%2F2016-2-2-%E8%AF%BB%EF%BC%9A%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[陈老师｜如何搭建一个属于自己的直播平台 现在直播非常火爆，可以从PC或手机直播，然后从PC或是手机或是支持HTML5的浏览器收看。但是，你知道直播平台后面的技术和实现原理码？ 正好去年过年的时候，一个朋友破解了AirPlay和Chromecast协议，然后开发了一套技术能够截获和播放任何手机（iOS或是Android）屏幕上的任何内容。想到的第一个应用是做一个直播的直播服务（如有感兴趣的投资人，可以联系）。比如，通过屏幕直播，你可以邀请朋友看你正在看的直播的电影，球赛，演唱会，晚会，不管是免费的还是付费的。当初的想法是将屏幕的内容，通过AirPlay或Chromecast，推送到后台服务器，然后，受邀的朋友就可以从浏览器或是其它视频播放器观看了。为此，我们搭建和开发了一个直播平台，现在把我们实现的过程记录下来和大家共享。 首先，视频有它的播放协议。原则上，RTSP，RTMP，HTTP都可以做直播和点播，但一般做直播用RTSP和RTMP，做点播用HTTP。我们选用的是RTMP协议。 RTMP 协议 RTMP（Real Time Message Protocol／实时信息传输协议）是应用层协议，靠底层传输层协议（通常是TCP）来保证信息传输的可靠性的。在TCP链接建立后，RTMP协议也要客户端和服务器通过“握手”来建立RTMP Connection，然后在Connection上传输控制信息。RTMP协议传输时会对数据格式化，而实际传输的时候为了更好地实现多路复用、分包和信息的公平性，发送端会把Message划分为带有Message ID的Chunk，每个Chunk可能是一个单独的Message，也可能是Message的一部分，在接受端会根据Chunk中包含的data的长度，message id和message的长度把chunk还原成完整的Message，从而实现信息的收发。 我们看看两个常用的视频服务。一个是由客户端向服务器发起请求推流到服务器，这个就是直播的播放服务，流程如下。 另一个是由客户端向服务器发起请求从服务器端接受数据，可以多次调用，这就是播放服务。流程如下。 RTMP是直播后面的协议，有很多的开源软件实现了，细节我们不再细说。下面，我们看看怎么搭建后台服务系统。 安装和配置 LEMP LEMP栈是指Linux（L）, NGINX（E）, MySQL（M）, PHP（P），还记得LAMP吗？LEMP既是将NGINX（E）取代了Apache（A）。 首先，用以下命令安装和启动NGINX web server。123# sudo apt-get update# sudo apt-get install nginx# sudo service nginx start 接着，安装MySQL。1# sudo apt-get install mysql-server mysql php5-mysql 接着，安装和配置PHP。123456789# sudo apt-get install php5-fpmlocation ~ .php$ &#123; try_files $uri =404; fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 最后，重新启动NGINX web server。1# sudo service nginx restart 这样，后台的web server设置好了，可以对外提供网页和PHP服务了。但是，NGINX并不支持RTMP协议，我们需要下载，编译，安装和配置RTMP模块。 安装和配置nginx-rtmp-module首先，下载NGINX的源代码，确保环境下能正确的编译。1# git clone https://github.com/nginx/nginx.git 然后，下载RTMP模块。1# git clone https://github.com/arut/nginx-rtmp-module.git 然后，cd到NGINX的源代码目录，config，make和install 刚才下载的RTMP模块。123# ./configure --add-module=/path/to/nginx-rtmp-module make make install# make# make install 最后，在NGINX的配置文件中，加上RTMP相关的配置，并且重新启动NGINX server。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758rtmp &#123; server &#123; listen 1935; chunk_size 4000; # HLS application hls &#123; live on; hls on; hls_path /tmp/hls; &#125; # MPEG-DASH is similar to HLS application dash &#123; live on; dash on; dash_path /tmp/dash; &#125; &#125;&#125;# HTTP can be used for accessing RTMP statshttp &#123; server &#123; listen 8080; # This URL provides RTMP statistics in XML location /stat &#123; rtmp_stat all; # Use this stylesheet to view XML as web page # in browser rtmp_stat_stylesheet stat.xsl; &#125; location /stat.xsl &#123; # XML stylesheet to view RTMP stats. # Copy stat.xsl wherever you want # and put the full directory path here root /path/to/stat.xsl/; &#125; location /hls &#123; # Serve HLS fragments types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root /tmp; add_header Cache-Control no-cache; &#125; location /dash &#123; # Serve DASH fragments root /tmp; add_header Cache-Control no-cache; &#125; &#125;&#125; 其中看到了服务器上视频存储的格式是HLS，下面需要介绍一下这个格式。 HLS（HTTP Live Streaming） HLS是一个由苹果公司提出的基于HTTP的流媒体网络传输协议，它把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。开始播放时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。工作原理如下。 m3u8 playlist的文件结构，它不是一个单独的文件，而是由一系列文件组成。Index文件和很多的数据文件。 一个m3u8 playlist的index文件内容。 所有的数据文件，以.ts为后缀，存放在同一目录下面。 直播客户端（后面我们要介绍的OBS）将实时视频推送到NGINX的RTMP模块。RTMP模块会根据配置将视频流转换成HLS文件。这时，HLS文件可以使用两种模式播放。一是点播VOD模式，下载当前时间点可以获取到所有index文件和ts文件，并播放。这种模式允许客户端访问全部内容，不一定是实时内容。二是Live 模式，实时生成m3u8和ts文件。它的索引文件一直处于动态变化的，播放的时候需要不断下载index文件，以获得最新生成的ts文件播放视频。一般来说，实况直播时，会有一些延时。下面，来看一个JS实现的HLS player，嵌入到支持HTML5的浏览器就可以播放HLS文件。 HLSPlayer 基于Javascript的HLS Player可以在PC浏览器（IE，Chrome，Firefox，Safari，等），iOS的Safari，Android的Chrome，等等支持HTML5的浏览器上播放。市面上有很多开源的，下面图中是其中的一种，对于不同浏览器的支持都很好。下载以后，按照它给的例子修改HLS的源就可以了。 除了JS的播放器，还有独立的播放器，ffmpeg是广泛使用的一种命令行播放器，支持Windows，Linux，Mac等。 ffmpeg ffmpeg是一个非常快的视频/音频转换器，也可以现场抓取音频/视频源，并在任意采样率、尺寸之间调整视频，以及提供多种高品质的滤镜系统。ffmpeg从任意数量/形式的输入文件中进行读取，通过输入文件选项对输入文件进行设定，并写入到任意数量/形式的输出文件中。它不但可以对任何格式的音视频文件相互转化，而且可以播放任何格式的音视频文件。它的命令行选项超多，具体细节需要用到时自己去网上搜索和阅读。 例如，下面的命令将一个本地的视频文件movie.avi推送到服务器上可以生成HLS格式的文件。1# ffmpeg -loglevel verbose -re -i movie.avi -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1935/hls/movie OBS OBS（Open Broadcaster Software／开源直播软件），它是目前世界上最火的免费开源直播软件。由于它是免费的，而且质量高，对比其它软件就有天生的优势，很多商业化的直播平台都支持和推荐使用。下面是它的基础界面。 OBS能够讲视频流推送到支持RTMP协议的服务器上，需要进行一些简单的设置。服务器的地址，和流的密钥，这样，可以区分不同的用户，也保证了不同用户的内容安全。 直播平台Demo 基于上面描述的技术和开源系统，我们用PHP实现了一个简单的支持多用户的直播平台。用户可以注册，登录，follow/unfollow，评论，标签，收看，直播（每个用户有自己的直播密钥），等等。 源代码文件目录。 注册界面。 播放和评论界面。 直播使用的是OBS，也可以使用你喜欢的直播移动App，需要设置系统给每个用户提供的密钥。收看时，直接选择用户和他正在播放视频就好了。 直播的精髓都应该讨论到了，如果将系统sharding，分层，SOA化，负载均衡，cache，就可以搭建出一个可扩展的大规模的直播平台。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读：公司高速发展是对团队最好的管理]]></title>
    <url>%2F2015%2F12%2F18%2F2016%2F2015-12-18-%E5%85%AC%E5%8F%B8%E9%AB%98%E9%80%9F%E5%8F%91%E5%B1%95%E6%98%AF%E5%AF%B9%E5%9B%A2%E9%98%9F%E6%9C%80%E5%A5%BD%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考原文 #集权式的管理： #甩手掌柜 如果团队特别残缺，那可能就需要管理得比较细致，从一开始就要把团队搭建起来、培养好，如果这个团队是自我学习能力很强，每个人战斗力都很好，又是在做一些创新性的东西，需要很自由的空间的话，那就可以给他放权。 两种管理风格没有优劣之分，作为一个技术管理者，还是要根据实际的情况，看不同的团队状况及整个公司业务发展所处的阶段，灵活地选择解决问题的方法，不要墨守成规。 良性发展 ##公司的高速发展是对团队最好的管理比方说小米，从传统意义的管理上来说，小米内部的管理是很混乱的，结构扁平，面临很大的挑战和压力，但实际上，由于小米的快速发展和扩张，很多员工都像打了鸡血一样在那儿拼命干。这是非常关键的一点，如果公司特别有前途、有活力，让每个人都觉得特别有干劲的话，其实也不需要在管理上去做太多的事情。 如果一个公司本身在走下坡路，不管管理多么精细化、工作安排多么合理、对员工激励多么到位，在管理上做再多的工作，真正底下做事情的员工还是没有什么成就感的。 ##选对人很重要从管理的角度来说，选对人很重，选的人不合适，哪怕你花再多的心思、再多的努力，做事情还是事倍功半的；但如果能选对人的话，其实不需要你做太多，他就能把事情做得很好。 #需要思考是否要招人？ #建立学习型组织 #技术人要多分享与交流 #综合能力 现在创业，一个或两个创始人已经很难玩得转了，通常需要组建一个3-5人强大的创业团队，每个人都是各负其责，有负责战略的、业务的、产品的、研发的、市场的等等，一个团队配合起来才能把事情做好。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个功能引导页面的实现思路，参考美丽说App]]></title>
    <url>%2F2015%2F12%2F08%2F2015%2F%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%BC%95%E5%AF%BC%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E9%81%AE%E7%BD%A9%E6%95%88%E6%9E%9C%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[原型美丽说app的首页引导效果图如下：下载美丽说的apk，解压后，找到切图如下： 可以看到，由于切图右下角留出白色透明圆圈，所以有了上面的效果。 进一步思考由于android屏幕尺寸的碎片化，所以如果我们要做一张固定的切图，把透过来的部分留在固定位置并不是一个好的解决方案。所以可以考虑把“我”上面的圆圈用代码来绘制，如果要给让某一个控件透过压黑的背景显示出来，必须要精确控制背景要透明的效果。 实施获取控件的位置关键代码：1234567ImageView t = (ImageView)findViewById(R.id.l); t.getLocationOnScreen(location); int x = location[0]; int y = location[1]; System.out.println("x:" + x + "y:" + y); System.out.println("图片各个角Left：" + t.getLeft() + "Right：" + t.getRight() + "Top：" + t.getTop() + "Bottom：" + t.getBottom()); 制作屏幕宽高的图片12345678910111213141516/*** 生成对应颜色的全屏图像* @param context* @param color* @return*/public static Bitmap createColorWallpaer(Context context, int color) &#123;WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);Point outSize = new Point();wm.getDefaultDisplay().getSize(outSize);Bitmap bitmap = Bitmap.createBitmap(outSize.x, outSize.y, Bitmap.Config.ARGB_8888);if (bitmap != null) &#123;bitmap.eraseColor(color);&#125;return bitmap;&#125; outSize就是屏幕的尺寸。 获取状态栏高度因为制作背景图的时候，不要把状态栏算在内，所以制作背景图时，需要把状态栏的尺寸高度刨掉。123Rect frame = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);int statusBarHeight = frame.top; decorView是window中的最顶层view，可以从window中获取到decorView，然后decorView有个getWindowVisibleDisplayFrame方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。于是，我们就可以算出状态栏的高度了。 生成我们需要的Bitmap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*** 创建引导图像，在指定位置显示一个圆圈和圆角矩形* @param context* @param color* @return*/public static Bitmap createTipsWallpaer(Context context, int color) &#123;Bitmap bitmap = createColorWallpaer(context, color);// 创建画笔Paint p = new Paint();p.setColor(Color.TRANSPARENT);//设置图像的叠加模式p.setXfermode(new PorterDuffXfermode(Mode.SRC));Canvas canvas = new Canvas(bitmap);canvas.drawCircle(150, 150, 100, p);// 小圆//画圆角矩形p.setStyle(Paint.Style.FILL);//充满p.setAntiAlias(true);// 设置画笔的锯齿效果canvas.drawText("画圆角矩形:", 10, 260, p);RectF oval3 = new RectF(80, 260, 200, 300);// 设置个新的长方形canvas.drawRoundRect(oval3, 10, 10, p);//第二个参数是x半径，第三个参数是y半径try &#123;saveMyBitmap("yiyixiaozhi", bitmap);&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;return bitmap;&#125;/*** 保存Bitmap为本地文件* @param bitName* @param bmp* @throws IOException*/public static void saveMyBitmap(String bitName, Bitmap bmp) throws IOException &#123;File f = new File("/sdcard/Note/" + bitName + ".png");f.createNewFile();FileOutputStream fOut = null;try &#123;fOut = new FileOutputStream(f);&#125; catch (FileNotFoundException e) &#123;e.printStackTrace();&#125;bmp.compress(Bitmap.CompressFormat.PNG, 100, fOut);try &#123;fOut.flush();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;try &#123;fOut.close();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125; 下来我们用picasa打开本地保存的文件，成功了，效果如下： 注意，如果不对paint应用Mode.SRC（显示上层图像），是无法显示出来透明的部分的，截图如下：如有兴趣进一步探讨，欢迎订阅我的微信公众号（yiyixiaozhi）留言给我。或者在此博客下方进行评论。参考网址： Android利用canvas画各种图形(点、直线、弧、圆、椭圆、文字、矩形、多边形、曲线、圆角矩形) Android得到控件在屏幕中的坐标 Android bitmap图片处理 android中Bitmap对象怎么保存为文件? android 状态栏、标题栏、屏幕高度]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗意]]></title>
    <url>%2F2015%2F11%2F08%2F2015%2F2015%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2015-11-08 行走路上走行被琐事推着错过了和时间的会面 2015-11-1 自由如果脱离牢笼和羁绊那自由的空气呼吸起来新鲜极了 2015-11-15 情绪由于孩子比较到了好动的年龄。时不时就把水彩涂抹到自己的手上、脸上。所以我很生气。由于孩子在我上电脑工作的时候，总是来搅乱我，不断地抢断我的键盘和鼠标。所以我很生气。由于在我组装家具的时候，孩子总是跑跑跳跳，他在自己的世界中玩好玩的捉迷藏游戏，藏在很小的空间里面，不让我干活。所以我很生气。 可是我忘记了，孩子玩水彩时，会给我一只笔，要我分享她的快乐。可是我忘记了，在我玩电脑的时候，孩子会用头找空隙，想办法钻到我的怀里。让我教她这个好玩的事情。可是我忘记了，在我组装家具的时候，孩子会自己从外面把自己能搬动的小木板一个个搬到我的旁边。 我生气的样子，会把孩子吓哭。我生气的时候说的话，她会当真。 孩子在一步步成长，而我在一步步走向孩子气。 比孩子需要我的，我想，是我需要她的陪伴、她的教育。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AndroidApk签名方法]]></title>
    <url>%2F2015%2F11%2F02%2F2015%2FAndroidApk%E7%AD%BE%E5%90%8D%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[使用Eclipse导出签名key文件 打开Eclipse，进行如下操作：File–&gt;Export–&gt;Export Android Application–&gt;选择对应的Project–&gt;点击Next。 创建新的keystore文件 创建key 选择key作用到的apk文件编写BAT签名脚本编写脚本如下，请在jdk环境变量配置OK的前提下使用。12jarsigner -verbose -keystore test.key -storepass 111111 -signedjar demo_signed.apk demo.apk yiyixiaozhi@pause 注：也可以修改签名后的apk文件名称，举例如下（apk名称末尾带上签名时候的系统时间）：12345set/p option=请输入本目录待签名apk:set str0=&quot;%date:~0,4%%date:~5,2%%date:~8,2%&quot;set str1=&quot;%time:~0,2%%time:~3,2%%time:~6,2%&quot;jarsigner -verbose -keystore test.key -storepass 111111 -signedjar &quot;%option:~0,-4%&quot;_signed_&quot;%str0%&quot;_&quot;%str1%%option:~-4%&quot; &quot;%option%&quot; yiyixiaozhi@pause 输出apk文件名称如下：demo_signed_20151102_145726.apk jarsigner命令介绍 Jarsigner 选项 描述 -keystore.keystore 包含你私钥的存储文件 -verbose 显示输出动作。 -sigalg 签名算法，用 SHA1withRSA. -digestalg 消息摘要算法，用 SHA1. -storepass 存储文件的密码。主要为了安全起见，如果没提供，jarsigner会提示你输入。这个密码不会存储在你的shell历史记录中。 -keypass 私钥的密码。主要为了安全起见，如果没提供，jarsigner会提示你输入。这个密码不会存储在你的shell历史记录中。]]></content>
      <categories>
        <category>工具</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git命令的使用]]></title>
    <url>%2F2015%2F11%2F01%2F2015%2Fgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[#git 常用命令文件的状态变化周期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758检查当前文件状态$ git status跟踪新文件$ git add README //READ ME进入已暂存状态状态简览$ git status -s M READMEMM Rakefile A lib/git.rbM lib/simplegit.rb?? LICENSE.txt忽略文件.gitignore$ cat .gitignore*.[oa] //忽略所有以 .o 或 .a 结尾的文件*~ //忽略所有以波浪符（~）结尾的文件查看已暂存和未暂存的修改git diffgit diff --cached //查看已暂存的将要添加到下次提交里的内容提交更新git commit -m &quot;Story 182: Fix benchmarks for speed&quot;git commit -am &quot;Story 182: Fix benchmarks for speed&quot; //跳过使用暂存区域从已跟踪文件清单中移除,从暂存区域移除下一次提交时，该文件就不再纳入版本管理了.$ git rm PROJECTS.md$ git rm --cached README //从暂存区域移除），但保留在当前工作目录中移动(重命名)文件$ git mv file_from file_to查看提交历史$ git log取消暂存的文件$ git reset HEAD CONTRIBUTING.md撤消对文件的修改$ git checkout -- CONTRIBUTING.md查看远程仓库$ git remote -v添加远程仓库git remote add pb https://github.com/paulboone/ticgit从远程仓库中抓取与拉取git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。推送到远程仓库git push [remote-name] [branch-name] #git 分支1234567891011121314151617181920212223分支创建$ git branch testing //创建分支$ git checkout -b iss53 //新建一个分支并同时切换到那个分支上$ git checkout master //切换分支//合并hotfix到master分支， git commit 来完成合并提交$ git checkout master$ git merge hotfix//删除分支git branch -d iss53//查看每一个分支的最后一次提交$ git branch -v//新建本地分支，推送到远程，然后设置跟踪关系$ git branch testing2$ git push origin testing2:testing2-remote$ git checkout testing2$ git branch --set-upstream-to=origin/testing2-remote//本地新建一个远程同名分支并跟踪$ git checkout -t origin/testing-remote git代码仓库如何迁移从原地址克隆一份裸版本库。语法：1git clone --bare &lt;repository&gt; &lt;directory.git&gt; 例如：1git clone --bare git@git.oschina.net:yiyixiaozhi/BookCode.git 然后到新的 Git 服务器上创建一个目标项目（准备迁移过去）。比如新项目地址是：1git@github.com:bxh7425014/BookCode.git 以镜像推送的方式上传代码到github服务器上，如下：12$ cd BookCode.git/$ git push --mirror git@github.com:bxh7425014/BookCode.git OSChina git 代码fork及PR指南2016-09-16 分支命名规则：项目代码分为3个特性分支，命名规则为：开发版本：特性名_master测试版本：特性名_test_branch正式版本：特性名_releasebranch注：如果是默认项目，特性名可以省略。否则需要加上对应的特性名称，比如当前在当前项目基础上给某单位/组织/地域开发项目时，特性名前缀为对应的拼音，首字母大写，比如给西安开发某项目，分支名称为Xian**_**。 Fork仓库，本地修改后提交PRFork之后，个人名下就可以看到Fork出来的仓库了，对应的分支也能看到： 找到地址，clone代码下来： 在默认的master分支，修改Fork出来的本地文件： Commit后，push刚才的修改到OSChina个人名下的master分支： 刷新OSChina个人名下仓库，可以看到对应的ReadMe文件已经修改了，点击Pull Request： 制定源分支、目标分支、代码审查人员， PR提交给组织了，上面我们指定了“刘超”审查代码，“卞晓辉”进行测试。可以看到状态是未审核，未测试。 对应的人员会收到审查和测试通知，如下： 审查和测试通过后，可以接受代码合并了，如下： 合并后，如果还有一次反悔的机会，慎重使用： 可以看到对应的修改已经更新到主仓库上（XAVito/HelloWorld）。如下： Fork仓库同步主仓库的最新代码主仓库主分支更新了内容，如下： Fork仓库同步主仓库的更新： 更新后查看差异（注意当前在Fork仓库的master分支上），有如下两种方式： 测试在Fork出来的仓库master分支做增量修改并提交（预期会产生冲突）。如下： 试用merge，产生冲突，如下： 解决冲突，并提交代码到Fork仓库： 但与此同时主仓库也前进了，如下： Fork仓库提交更新到主仓库（PR审查代码勾选上），提交PR后，主仓库收到更新通知了：： 审查没有问题，通过，发现和主仓库的修改有冲突了，如下： 好办，解决冲突： 注：对于冲突的代码，代码审核人员必须要大家解决冲突，对于存在冲突的PR，关闭PR并评论。进一步学习合并最近的多次提交参考地址变基分支是很让人讨厌的，因为代码提交历史不够整洁。也有办法让他归到一个分支上去，使用rebase。方法请参考【变基】。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Excel统计加班]]></title>
    <url>%2F2015%2F10%2F28%2F2015%2F%E4%BD%BF%E7%94%A8Excel%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%8A%A0%E7%8F%AD%E6%97%B6%E9%97%B4%EF%BC%8C%E5%89%A5%E7%A6%BB%E5%8D%88%E4%BC%91%E6%97%B6%E9%97%B4%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[需求由于行政mm在整理同事们加班时间Excel表格的时候，不想要统计12:00~13:00时段。产生需求。因此，晚上加班研究了一下此问题。百度得知Excel有接收正则表达式的语法。 实施绘制草图把可能性都罗列了一遍，绘制草图如下： Excel只接受类似于正则表达式的方法编写公式，写法类似如下： 上班的考勤结果计算公式： 1=IF(AND(D2&gt;=VALUE(&quot;07:35&quot;))=TRUE,&quot;迟到&quot;,IF(D2=0,&quot;未打卡&quot;,&quot;&quot;)) 此公式的意思是，如果“D2”格，即上班时间列中的时间大于等于“7：35”，则显示“迟到”，如果“D2”格中无数据，即为“0”的时候，则显示“未打卡”，以上两个条件都不符合的时候，则显示为空白，即正常上班的意思； 下班的考勤结果计算公式： 1=IF(AND(E2&gt;=VALUE(&quot;16:30&quot;))=TRUE,&quot;加班&quot;,IF(E2=0,&quot;未打卡&quot;,&quot;早退&quot;)) 此公式的意思是，如果“E2”格，即下班时间列中的时间大于等于“16：30”，则显示为“加班”，如果“E2”格中无数据，即为“0”的时候，则显示“未打卡”，以上两个条件都不符合的时候，则显示为“早退” 代码模拟根据草图来看，由于Excel只接受if，不接受else if 写法，所以用Eclipse进行代码模拟，编写代码如下：12345678910111213141516171819202122232425262728293031323334/*** @param B2 代表B2单元格* @param C2 代表C2单元格* @return 处理结果*/public int test(int B2, int C2) &#123;int R = 0;if (C2&lt;=B2) &#123; //结束时间早于起始时间的话，结果为0R = 0;&#125; else &#123;if (B2&lt;=12) &#123; // 12表示12点整if (C2&lt;=12) &#123;R=C2-B2;&#125; else &#123;if(C2&gt;13) &#123; //13表示13点整R = C2-B2-1; //1表示1个小时&#125; else &#123;R=12-B2;&#125;&#125;&#125; else &#123;if (B2&gt;13) &#123;R=C2-B2;&#125; else &#123;if (C2&gt;13) &#123;R=C2-13;&#125; else &#123;R=0;&#125;&#125;&#125;&#125;return R;&#125; 代码转换将上面编写的代码转换浓缩为Excel能够接受的公式，转换结果如下：1D2=IF(C2&lt;=B2,0,IF(B2&lt;=TIME(12,0,0),IF(C2&lt;=TIME(12,0,0),C2-B2,IF(C2&gt;TIME(13,0,0),C2-B2-TIME(1,0,0),TIME(12,0,0)-B2)),IF(B2&gt;TIME(13,0,0),C2-B2,IF(C2&gt;TIME(13,0,0),C2-TIME(13,0,0),0)))) 输出编写时间进行测试结果截图如下： Excel示例文档加班统计表格测试.xlsxhttp://yunpan.cn/cFbKSEQSV5Ln3 访问密码 2444]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2015%2F09%2F08%2F2015%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义工厂方法模式定义了一个创建对象的接口，但有子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。类图工厂方法模式能够封装具体类型的实例化。看看下面的类图，抽象的Creator提供了一个创建对象的方法的接口，也称为“工厂方法”。在抽象的Creator中，任何其他实现的方法，都可能使用到这个工厂方法所制造出来的产品，但只有子类真正实现这个工厂方法并创建产品。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《门后的秘密》]]></title>
    <url>%2F2015%2F06%2F02%2F2016%2F2015-6-2-%E5%A6%82%E4%BD%95%E2%80%9C%E6%9C%89%E6%95%88%E5%9C%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E4%BC%9A%E8%B0%88%E2%80%9D%2F</url>
    <content type="text"><![CDATA[一对一会谈的最大好处之一就是帮助你与同事建立和谐的关系。如果你的一对一会谈进行得不太顺利，检查自己的行为。在会谈中，你是说得多，还是主要在聆听并提问题？确保自己没有做出任何打断一对一会谈的行为。比如，如果你的上司走了进来，你应该礼貌并坚定地说：“我现在正在开会，这个会议很重要，会议结束后，我马上去找你。”不要让你的上司形成习惯，认为他可以不尊重你和你的团队成员。 #问候问问对方近况如何。 #谈论现状和工作进程 了解下属上个星期都完成了什么工作，哪些本来计划要完成的工作还没有完成。 下周的工作计划是什么。 #障碍在一对一的会谈时，我们会询问下属是否遇到了障碍。如果我们不问，下属就会独自承担，认为自己不应该告诉我们，并必须独自奋斗。 #帮助一定要先询问对方是否需要帮助。帮助的形式有很多： 与对方共同解决问题 想出备选解决方案 充分讨论可选方案 指明具体信息，或者就是倾听。 #职业培训关注团队成员的职业发展可以建立双方的关系和信任，而且团队成员不会认为你只是在压榨他们，让他们完成尽可能多的工作，而是真正关心他们的职业和兴趣。注重职业培训，你就可以留住最好的雇员。 #其他讨论话题 给团队成员留出时间，讨论他们想要讨论的问题。 如果争端需要得到解决，鼓励并指导当事人来解决。 注意：一定不要将自己卷入他人的争端中。 #回顾行动计划（你的和团队其他成员的）对你们双方在一对一的会谈时讨论出的行动计划进行总结，并确定新的行动计划。 尤其要关注那些障碍消除计划。 #做记录笔记可以将之前的讨论记录在案，并记录下工作机会（你的和团队成员的）。在每次一对一会谈开始之前，要先回顾前几周会议的笔记，目的是了解应该跟进哪些工作、继续深入探索哪些内容，以及汇报你自己对工作计划的执行情况。 #在一对一会谈时解决问题 只要可能，在制定工作计划的时候，要求你的员工将工作分解成一个个的最小子任务，即在一两天内就可以交付出某些成果的子任务。 双方都清楚地知道怎样的结果才意味着完成了一个子任务，并且可以保证双方都能了解团队成员的最高优先级的工作。 #后记以下这些问题可以使团队成员的工作进程可见。 你怎样知道自己已经完成了这项任务？ 你会通过哪几个步骤来完成这件工作？ 你会首先处理哪部分工作？ 就目前你已完成的部分，你能够提供出一个概况或者某种衡量方法吗？ 你需要和他人共同合作吗？ 你怎么衡量工作是否有了进展？]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《空谷幽兰》]]></title>
    <url>%2F2015%2F06%2F02%2F2016%2F%E8%AF%BB%E3%80%8A%E7%A9%BA%E8%B0%B7%E5%B9%BD%E5%85%B0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[第六章 登天之道2016-9-16文摘： 不知香积寺，数里入云峰。古木无人径，深山何处钟。泉声咽危石，日色冷青松。薄暮空潭曲，安禅制毒龙。 2016-12-1摘录1 如果你不守戒，不管是一条戒还是二百五十条戒（比丘戒），你的生活都不会有安宁。你守戒的时候，就能够清除障碍和执著。只有到那个时候，你的禅定才能够深入。而只有通过禅定，你才能开悟。这就是律宗背后的逻辑。 摘录2 由山峰、青松和白云所构成的全景，每几秒钟就会变化一次。我抽掉了一整根雪茄，就坐在那里看着，听着我心爱的曲子——松间的风声。 完整语音链接]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
</search>
